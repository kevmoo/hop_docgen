{"name":"Request","qualifiedName":"shelf/shelf.Request","comment":"<p>Represents an HTTP request to be processed by a Shelf application.</p>","isAbstract":false,"superclass":"shelf/shelf.Message","implements":[],"subclass":[],"variables":{"method":{"name":"method","qualifiedName":"shelf/shelf.Request.method","comment":"<p>The HTTP request method, such as \"GET\" or \"POST\".</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"protocolVersion":{"name":"protocolVersion","qualifiedName":"shelf/shelf.Request.protocolVersion","comment":"<p>The HTTP protocol version used in the request, either \"1.0\" or \"1.1\".</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"requestedUri":{"name":"requestedUri","qualifiedName":"shelf/shelf.Request.requestedUri","comment":"<p>The original <a>dart-core.Uri</a> for the request.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"annotations":[]},"scriptName":{"name":"scriptName","qualifiedName":"shelf/shelf.Request.scriptName","comment":"<p>The initial portion of the <a>shelf/shelf.Request.requestedUri</a> path that corresponds to the\nhandler.</p>\n<p><a>shelf/shelf.Request.scriptName</a> allows a handler to know its virtual \"location\".</p>\n<p>If the handler corresponds to the \"root\" of a server, it will be an\nempty string, otherwise it will start with a <code>/</code></p>\n<p><a>shelf/shelf.Request.scriptName</a> and <a>shelf/shelf.Request.url</a> combine to create a valid path that should\ncorrespond to the <a>shelf/shelf.Request.requestedUri</a> path.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"url":{"name":"url","qualifiedName":"shelf/shelf.Request.url","comment":"<p>The remainder of the <a>shelf/shelf.Request.requestedUri</a> path and query designating the virtual\n\"location\" of the request's target within the handler.</p>\n<p><a>shelf/shelf.Request.url</a> may be an empty, if <a>shelf/shelf.Request.requestedUri</a>targets the handler\nroot and does not have a trailing slash.</p>\n<p><a>shelf/shelf.Request.url</a> is never null. If it is not empty, it will start with <code>/</code>.</p>\n<p><a>shelf/shelf.Request.scriptName</a> and <a>shelf/shelf.Request.url</a> combine to create a valid path that should\ncorrespond to the <a>shelf/shelf.Request.requestedUri</a> path.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"annotations":[]}},"inheritedVariables":{"context":{"name":"context","qualifiedName":"shelf/shelf.Message.context","comment":"<p>Extra context that can be used by for middleware and handlers.</p>\n<p>For requests, this is used to pass data to inner middleware and handlers;\nfor responses, it's used to pass data to outer middleware and handlers.</p>\n<p>Context properties that are used by a particular package should begin with\nthat package's name followed by a period. For example, if logRequests\nwanted to take a prefix, its property name would be <code>\"shelf.prefix\"</code>,\nsince it's in the <code>shelf</code> package.</p>\n<p>The value is immutable.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.Object","inner":[]}]}],"annotations":[]},"headers":{"name":"headers","qualifiedName":"shelf/shelf.Message.headers","comment":"<p>The HTTP headers.</p>\n<p>The value is immutable.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"annotations":[]}},"methods":{"setters":{},"getters":{"canHijack":{"name":"canHijack","qualifiedName":"shelf/shelf.Request.canHijack","comment":"<p>Whether this request can be hijacked.</p>\n<p>This will be <code>false</code> either if the adapter doesn't support hijacking, or\nif the request has already been hijacked.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"ifModifiedSince":{"name":"ifModifiedSince","qualifiedName":"shelf/shelf.Request.ifModifiedSince","comment":"<p>If this is non-<code>null</code> and the requested resource hasn't been modified\nsince this date and time, the server should return a 304 Not Modified\nresponse.</p>\n<p>This is parsed from the If-Modified-Since header in <a>shelf/shelf-message.Message.headers</a>. If\n<a>shelf/shelf-message.Message.headers</a> doesn't have an If-Modified-Since header, this will be <code>null</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.DateTime","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"shelf/shelf.Request.Request-","comment":"<p>Creates a new <a>shelf/shelf.Request</a>.</p>\n<p>If <a>shelf/shelf.Request.Request-.url</a> and <a>shelf/shelf.Request.Request-.scriptName</a> are omitted, they are inferred from\n<a>shelf/shelf.Request.Request-.requestedUri</a>.</p>\n<p>Setting one of <a>shelf/shelf.Request.Request-.url</a> or <a>shelf/shelf.Request.Request-.scriptName</a> and not the other will throw an\n<a>dart-core.ArgumentError</a>.</p>\n<p>The default value for <a>shelf/shelf.Request.Request-.protocolVersion</a> is '1.1'.</p>\n<h2><code>onHijack</code></h2>\n<p><a>shelf/shelf.Request.Request-.onHijack</a> allows handlers to take control of the underlying socket for\nthe request. It should be passed by adapters that can provide access to\nthe bidirectional socket underlying the HTTP connection stream.</p>\n<p>The <a>shelf/shelf.Request.Request-.onHijack</a> callback will only be called once per request. It will be\npassed another callback which takes a byte stream and a byte sink.\n<a>shelf/shelf.Request.Request-.onHijack</a> must pass the stream and sink for the connection stream to this\ncallback, although it may do so asynchronously. Both parameters may be the\nsame object. If the user closes the sink, the adapter should ensure that\nthe stream is closed as well.</p>\n<p>If a request is hijacked, the adapter should expect to receive a\n<a>shelf/shelf.HijackException</a> from the handler. This is a special exception used to\nindicate that hijacking has occurred. The adapter should avoid either\nsending a response or notifying the user of an error if a\n<a>shelf/shelf.HijackException</a> is caught.</p>\n<p>An adapter can check whether a request was hijacked using <a>shelf/shelf.Request.canHijack</a>,\nwhich will be <code>false</code> for a hijacked request. The adapter may throw an\nerror if a <a>shelf/shelf.HijackException</a> is received for a non-hijacked request, or if\nno <a>shelf/shelf.HijackException</a> is received for a hijacked request.</p>\n<p>See also <a>shelf/shelf.Request.hijack</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"method":{"name":"method","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"requestedUri":{"name":"requestedUri","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]},"protocolVersion":{"name":"protocolVersion","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"headers":{"name":"headers","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"url":{"name":"url","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]},"scriptName":{"name":"scriptName","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":true,"named":true,"default":false,"type":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}]}],"value":null,"annotations":[]},"context":{"name":"context","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.Object","inner":[]}]}],"value":null,"annotations":[]},"onHijack":{"name":"onHijack","optional":true,"named":true,"default":false,"type":[{"outer":"shelf/shelf.OnHijackCallback","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{"change":{"name":"change","qualifiedName":"shelf/shelf.Request.change","comment":"<p>Creates a new <a>shelf/shelf.Request</a> by copying existing values and applying specified\nchanges.</p>\n<p>New key-value pairs in <a>shelf/shelf.Request.change.context</a> and <a>shelf/shelf.Request.change.headers</a> will be added to the copied\n<a>shelf/shelf.Request</a>.</p>\n<p>If <a>shelf/shelf.Request.change.context</a> or <a>shelf/shelf.Request.change.headers</a> includes a key that already exists, the\nkey-value pair will replace the corresponding entry in the copied\n<a>shelf/shelf.Request</a>.</p>\n<p>All other context and header values from the <a>shelf/shelf.Request</a> will be included\nin the copied <a>shelf/shelf.Request</a> unchanged.</p>\n<p>If <a>shelf/shelf.Request.change.scriptName</a> is provided and <a>shelf/shelf.Request.change.url</a> is not, <a>shelf/shelf.Request.change.scriptName</a> must be a\nprefix of this.url. <a>shelf/shelf.Request.change.url</a> will default to this.url with this prefix\nremoved. Useful for routing middleware that sends requests to an inner\nHandler.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"shelf/shelf.Request","inner":[]}],"parameters":{"headers":{"name":"headers","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"context":{"name":"context","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.Object","inner":[]}]}],"value":null,"annotations":[]},"scriptName":{"name":"scriptName","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"url":{"name":"url","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"hijack":{"name":"hijack","qualifiedName":"shelf/shelf.Request.hijack","comment":"<p>Takes control of the underlying request socket.</p>\n<p>Synchronously, this throws a <a>shelf/shelf.HijackException</a> that indicates to the\nadapter that it shouldn't emit a response itself. Asynchronously,\n<a>shelf/shelf.Request.hijack.callback</a> is called with a Stream&lt;<a>dart-core</a>&lt;<a>dart-core</a>>> and\nStreamSink&lt;<a>dart-core</a>&lt;<a>dart-core</a>>>, respectively, that provide access to the\nunderlying request socket.</p>\n<p>If the sink is closed, the stream will be closed as well. The stream and\nsink may be the same object, as in the case of a <code>dart:io</code> <code>Socket</code>\nobject.</p>\n<p>This may only be called when using a Shelf adapter that supports\nhijacking, such as the <code>dart:io</code> adapter. In addition, a given request may\nonly be hijacked once. <a>shelf/shelf.Request.canHijack</a> can be used to detect whether this\nrequest can be hijacked.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"shelf/shelf.HijackCallback","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"contentLength":{"name":"contentLength","qualifiedName":"shelf/shelf.Request.contentLength","comment":"<p>The contents of the content-length field in <a>shelf/shelf-message.Message.headers</a>.</p>\n<p>If not set, <code>null</code>.</p>","commentFrom":"","inheritedFrom":"shelf.Message.contentLength","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"encoding":{"name":"encoding","qualifiedName":"shelf/shelf.Request.encoding","comment":"<p>The encoding of the message body.</p>\n<p>This is parsed from the \"charset\" paramater of the Content-Type header in\n<a>shelf/shelf-message.Message.headers</a>.</p>\n<p>If <a>shelf/shelf-message.Message.headers</a> doesn't have a Content-Type header or it specifies an\nencoding that dart:convert doesn't support, this will be <code>null</code>.</p>","commentFrom":"","inheritedFrom":"shelf.Message.encoding","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-convert.Encoding","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"shelf/shelf.Request.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>shelf/shelf.Request.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"mimeType":{"name":"mimeType","qualifiedName":"shelf/shelf.Request.mimeType","comment":"<p>The MIME type of the message.</p>\n<p>This is parsed from the Content-Type header in <a>shelf/shelf-message.Message.headers</a>. It contains only\nthe MIME type, without any Content-Type parameters.</p>\n<p>If <a>shelf/shelf-message.Message.headers</a> doesn't have a Content-Type header, this will be <code>null</code>.</p>","commentFrom":"","inheritedFrom":"shelf.Message.mimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"shelf/shelf.Request.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"shelf/shelf.Request.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>shelf/shelf.Request.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>shelf/shelf.Request.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"change":{"name":"change","qualifiedName":"shelf/shelf.Request.change","comment":"<p>Creates a new <a>shelf/shelf.Message</a> by copying existing values and applying specified\nchanges.</p>","commentFrom":"","inheritedFrom":"shelf.Message.change","static":false,"abstract":true,"constant":false,"return":[{"outer":"shelf/shelf.Message","inner":[]}],"parameters":{"headers":{"name":"headers","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"context":{"name":"context","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.Object","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"shelf/shelf.Request.noSuchMethod","comment":"<p><a>shelf/shelf.Request.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>shelf/shelf.Request.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>shelf/shelf.Request.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>shelf/shelf.Request.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"read":{"name":"read","qualifiedName":"shelf/shelf.Request.read","comment":"<p>Returns a <a>shelf/dart-async.Stream</a> representing the body.</p>\n<p>Can only be called once.</p>","commentFrom":"","inheritedFrom":"shelf.Message.read","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}]}],"parameters":{},"annotations":[]},"readAsString":{"name":"readAsString","qualifiedName":"shelf/shelf.Request.readAsString","comment":"<p>Returns a <a>shelf/dart-async.Future</a> containing the body as a String.</p>\n<p>If <a>shelf/shelf.Request.readAsString.encoding</a> is passed, that's used to decode the body.\nOtherwise the encoding is taken from the Content-Type header. If that\ndoesn't exist or doesn't have a \"charset\" parameter, UTF-8 is used.</p>\n<p>This calls <a>shelf/shelf.Request.read</a> internally, which can only be called once.</p>","commentFrom":"","inheritedFrom":"shelf.Message.readAsString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{"encoding":{"name":"encoding","optional":true,"named":false,"default":false,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"shelf/shelf.Request.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}