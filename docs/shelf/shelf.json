{"name":"shelf","qualifiedName":"shelf/shelf","comment":"","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"createMiddleware":{"name":"createMiddleware","qualifiedName":"shelf/shelf.createMiddleware","comment":"<p>Creates a <a>shelf/shelf.Middleware</a> using the provided functions.</p>\n<p>If provided, <a>shelf/shelf.createMiddleware.requestHandler</a> receives a <a>shelf/shelf.Request</a>. It can respond to\nthe request by returning a <a>shelf/shelf.Response</a> or Future&lt;Response>.\n<a>shelf/shelf.createMiddleware.requestHandler</a> can also return <code>null</code> for some or all requests in which\ncase the request is sent to the inner <a>shelf/shelf.Handler</a>.</p>\n<p>If provided, <a>shelf/shelf.createMiddleware.responseHandler</a> is called with the <a>shelf/shelf.Response</a> generated\nby the inner <a>shelf/shelf.Handler</a>. Responses generated by <a>shelf/shelf.createMiddleware.requestHandler</a> are not\nsent to <a>shelf/shelf.createMiddleware.responseHandler</a>.</p>\n<p><a>shelf/shelf.createMiddleware.responseHandler</a> should return either a <a>shelf/shelf.Response</a> or\nFuture&lt;Response>. It may return the response parameter it receives or\ncreate a new response object.</p>\n<p>If provided, <a>shelf/shelf.createMiddleware.errorHandler</a> receives errors thrown by the inner handler. It\ndoes not receive errors thrown by <a>shelf/shelf.createMiddleware.requestHandler</a> or <a>shelf/shelf.createMiddleware.responseHandler</a>, nor\ndoes it receive <a>shelf/shelf.HijackException</a>s. It can either return a new response or\nthrow an error.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"shelf/shelf.Middleware","inner":[]}],"parameters":{"requestHandler":{"name":"requestHandler","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{"request":{"name":"request","optional":false,"named":false,"default":false,"type":[{"outer":"shelf/shelf.Request","inner":[]}],"value":null,"annotations":[]}}}},"responseHandler":{"name":"responseHandler","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{"response":{"name":"response","optional":false,"named":false,"default":false,"type":[{"outer":"shelf/shelf.Response","inner":[]}],"value":null,"annotations":[]}}}},"errorHandler":{"name":"errorHandler","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{"error":{"name":"error","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"stackTrace":{"name":"stackTrace","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.StackTrace","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"logRequests":{"name":"logRequests","qualifiedName":"shelf/shelf.logRequests","comment":"<p>Middleware which prints the time of the request, the elapsed time for the\ninner handlers, the response's status code and the request URI.</p>\n<p><a>shelf/shelf.logRequests.logger</a> takes two paramaters.</p>\n<p><code>msg</code> includes the request time, duration, request method, and requested\npath.</p>\n<p>For successful requests, <code>msg</code> also includes the status code.</p>\n<p>When an error is thrown, <code>isError</code> is true and <code>msg</code> contains the error\ndescription and stack trace.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"shelf/shelf.Middleware","inner":[]}],"parameters":{"logger":{"name":"logger","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{"msg":{"name":"msg","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"isError":{"name":"isError","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.bool","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]}}},"classes":{"class":[{"name":"Cascade","qualifiedName":"shelf/shelf.Cascade","preview":"<p>A helper that calls several handlers in sequence and returns the first\nacceptable response.</p>"},{"name":"HijackException","qualifiedName":"shelf/shelf.HijackException","preview":"<p>An exception used to indicate that a request has been hijacked.</p>"},{"name":"Pipeline","qualifiedName":"shelf/shelf.Pipeline","preview":"<p>A helper that makes it easy to compose a set of <a>shelf/shelf.Middleware</a> and a\n<a>shelf/shelf.Handler</a>.</p>"},{"name":"Request","qualifiedName":"shelf/shelf.Request","preview":"<p>Represents an HTTP request to be processed by a Shelf application.</p>"},{"name":"Response","qualifiedName":"shelf/shelf.Response","preview":"<p>The response returned by a Handler.</p>"}],"typedef":{"Handler":{"name":"Handler","qualifiedName":"shelf/shelf.Handler","comment":"<p>The signature of a function which handles a <a>shelf/shelf.Request</a>.</p>\n<p>A <a>shelf/shelf.Handler</a> may receive a request directly from an HTTP server or it\nmay be composed as part of a larger application.</p>\n<p>Should return Response or Future&lt;Response>.</p>","return":"dynamic","parameters":{"request":{"name":"request","optional":false,"named":false,"default":false,"type":[{"outer":"shelf/shelf.Request","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>The signature of a function which handles a <a>shelf/shelf.Request</a>.</p>"},"HijackCallback":{"name":"HijackCallback","qualifiedName":"shelf/shelf.HijackCallback","comment":"<p>A callback provided by a Shelf handler that's passed to <a>shelf/shelf.Request.hijack</a>.</p>","return":"void","parameters":{"stream":{"name":"stream","optional":false,"named":false,"default":false,"type":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}]}],"value":null,"annotations":[]},"sink":{"name":"sink","optional":false,"named":false,"default":false,"type":[{"outer":"dart-async.StreamSink","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>A callback provided by a Shelf handler that's passed to <a>shelf/shelf.Request.hijack</a>.</p>"},"Middleware":{"name":"Middleware","qualifiedName":"shelf/shelf.Middleware","comment":"<p>A function which creates a new <a>shelf/shelf.Handler</a> by wrapping a <a>shelf/shelf.Handler</a>.</p>\n<p>You can extend the functions of a <a>shelf/shelf.Handler</a> by wrapping it in\n<a>shelf/shelf.Middleware</a> that can intercept and process a request before it it sent\nto a handler, a response after it is sent by a handler, or both.</p>\n<p>Because <a>shelf/shelf.Middleware</a> consumes a <a>shelf/shelf.Handler</a> and returns a new\n<a>shelf/shelf.Handler</a>, multiple <a>shelf/shelf.Middleware</a> instances can be composed\ntogether to offer rich functionality.</p>\n<p>Common uses for middleware include caching, logging, and authentication.</p>\n<p>Middleware that captures exceptions should be sure to pass\n<a>shelf/shelf.HijackException</a>s on without modification.</p>\n<p>A simple <a>shelf/shelf.Middleware</a> can be created using <a>shelf/shelf.createMiddleware</a>.</p>","return":"shelf.Handler","parameters":{"innerHandler":{"name":"innerHandler","optional":false,"named":false,"default":false,"type":[{"outer":"shelf/shelf.Handler","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>A function which creates a new <a>shelf/shelf.Handler</a> by wrapping a <a>shelf/shelf.Handler</a>.</p>"},"OnHijackCallback":{"name":"OnHijackCallback","qualifiedName":"shelf/shelf.OnHijackCallback","comment":"<p>A callback provided by a Shelf adapter that's used by <a>shelf/shelf.Request.hijack</a> to\nprovide a <a>shelf/shelf.HijackCallback</a> with a socket.</p>","return":"void","parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"shelf/shelf.HijackCallback","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>A callback provided by a Shelf adapter that's used by <a>shelf/shelf.Request.hijack</a> to\nprovide a <a>shelf/shelf.HijackCallback</a> with a socket.</p>"}},"error":[]},"packageName":"shelf","packageIntro":"<h2>Web Server Middleware for Dart</h2>\n<h2>Introduction</h2>\n<p><strong>Shelf</strong> makes it easy to create and compose <strong>web servers</strong> and <strong>parts of web\nservers</strong>. How?</p><ul><li>Expose a small set of simple types.</li><li>\n<p>Map server logic into a simple function: a single argument for the request,\nthe response is the return value.</p></li><li>Trivially mix and match synchronous and asynchronous processing.</li><li>Flexibliity to return a simple string or a byte stream with the same model.</li></ul>\n<h2>Example</h2>\n<p>See <code>example/example_server.dart</code></p>\n<pre class=\"dart\"><code>import 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart' as io;\n\nvoid main() {\n  var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())\n      .addHandler(_echoRequest);\n\n  io.serve(handler, 'localhost', 8080).then((server) {\n    print('Serving at http://${server.address.host}:${server.port}');\n  });\n}\n\nshelf.Response _echoRequest(shelf.Request request) {\n  return new shelf.Response.ok('Request for \"${request.url}\"');\n}\n</code></pre>\n<h2>Handlers and Middleware</h2>\n<p>A <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Handler\">handler</a> is any function that handles a <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Request\">shelf.Request</a> and returns a\n<a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Response\">shelf.Response</a>. It can either handle the request itself--for example, a\nstatic file server that looks up the requested URI on the filesystem--or it can\ndo some processing and forward it to another handler--for example, a logger that\nprints information about requests and responses to the command line.</p>\n<p>The latter kind of handler is called \"<a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Middleware\">middleware</a>\", since it sits in the\nmiddle of the server stack. Middleware can be thought of as a function that\ntakes a handler and wraps it in another handler to provide additional\nfunctionality. A Shelf application is usually composed of many layers of\nmiddleware with one or more handlers at the very center; the <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Pipeline\">shelf.Pipeline</a>\nclass makes this sort of application easy to construct.</p>\n<p>Some middleware can also take multiple handlers and call one or more of them for\neach request. For example, a routing middleware might choose which handler to\ncall based on the request's URI or HTTP method, while a cascading middleware\nmight call each one in sequence until one returns a successful response.</p>\n<h2>Adapters</h2>\n<p>An adapter is any code that creates <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Request\">shelf.Request</a> objects, passes them to a\nhandler, and deals with the resulting <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Response\">shelf.Response</a>. For the most part,\nadapters forward requests from and responses to an underlying HTTP server;\n<a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf-io#id_serve\">shelf_io.serve</a> is this sort of adapter. An adapter might also synthesize\nHTTP requests within the browser using <code>window.location</code> and <code>window.history</code>,\nor it might pipe requests directly from an HTTP client to a Shelf handler.</p>\n<p>When implementing an adapter, some rules must be followed. The adapter must not\npass the <code>url</code> or <code>scriptName</code> parameters to <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Request#id_Request-\">new shelf.Request</a>; it should\nonly pass <code>requestedUri</code>. If it passes the <code>context</code> parameter, all keys must\nbegin with the adapter's package name followed by a period. If multiple headers\nwith the same name are received, the adapter must collapse them into a single\nheader separated by commas as per <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html\">RFC 2616 section 4.2</a>.</p>\n<p>An adapter must handle all errors from the handler, including the handler\nreturning a <code>null</code> response. It should print each error to the console if\npossible, then act as though the handler returned a 500 response. The adapter\nmay include body data for the 500 response, but this body data must not include\ninformation about the error that occurred. This ensures that unexpected errors\ndon't result in exposing internal information in production by default; if the\nuser wants to return detailed error descriptions, they should explicitly include\nmiddleware to do so.</p>\n<p>An adapter should include information about itself in the Server header of the\nresponse by default. If the handler returns a response with the Server header\nset, that must take precedence over the adapter's default header.</p>\n<p>An adapter should ensure that asynchronous errors thrown by the handler don't\ncause the application to crash, even if they aren't reported by the future\nchain. Specifically, these errors shouldn't be passed to the root zone's error\nhandler; however, if the adapter is run within another error zone, it should\nallow these errors to be passed to that zone. The following function can be used\nto capture only errors that would otherwise be top-leveled:</p>\n<pre class=\"dart\"><code>/// Run [callback] and capture any errors that would otherwise be top-leveled.\n///\n/// If [this] is called in a non-root error zone, it will just run [callback]\n/// and return the result. Otherwise, it will capture any errors using\n/// [runZoned] and pass them to [onError].\ncatchTopLevelErrors(callback(), void onError(error, StackTrace stackTrace)) {\n  if (Zone.current.inSameErrorZone(Zone.ROOT)) {\n    return runZoned(callback, onError: onError);\n  } else {\n    return callback();\n  }\n}\n</code></pre>\n<h2>Inspiration</h2><ul><li>\n<p><a href=\"http://www.senchalabs.org/connect/\">Connect</a> for NodeJS.\n* Read <a href=\"http://howtonode.org/connect-it\">this great write-up</a> to understand\n  the overall philosophy of all of these models.</p></li><li><a href=\"http://rack.github.io/\">Rack</a> for Ruby.</li><li><a href=\"http://legacy.python.org/dev/peps/pep-3333/\">WSGI</a> for Python.</li></ul>"}