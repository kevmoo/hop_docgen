{"name":"shelf-io","qualifiedName":"shelf/shelf-io","comment":"<p>A Shelf adapter for handling <a>shelf/dart-io.HttpRequest</a> objects from <code>dart:io</code>.</p>\n<p>One can provide an instance of <a>shelf/dart-io.HttpServer</a> as the <code>requests</code> parameter in\n<a>shelf/shelf-io.serveRequests</a>.</p>\n<p>The <code>dart:io</code> adapter supports request hijacking; see <a>shelf/shelf-request.Request.hijack</a>.</p>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"handleRequest":{"name":"handleRequest","qualifiedName":"shelf/shelf-io.handleRequest","comment":"<p>Uses <a>shelf/shelf-io.handleRequest.handler</a> to handle <a>shelf/shelf-io.handleRequest.request</a>.</p>\n<p>Returns a <a>shelf/dart-async.Future</a> which completes when the request has been handled.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"request":{"name":"request","optional":false,"named":false,"default":false,"type":[{"outer":"dart-io.HttpRequest","inner":[]}],"value":null,"annotations":[]},"handler":{"name":"handler","optional":false,"named":false,"default":false,"type":[{"outer":"shelf/shelf-typedef.Handler","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"serve":{"name":"serve","qualifiedName":"shelf/shelf-io.serve","comment":"<p>Starts an <a>shelf/dart-io.HttpServer</a> that listens on the specified <a>shelf/shelf-io.serve.address</a> and\n<a>shelf/shelf-io.serve.port</a> and sends requests to <a>shelf/shelf-io.serve.handler</a>.</p>\n<p>See the documentation for <a>shelf/dart-io.HttpServer.bind</a> for more details on <a>shelf/shelf-io.serve.address</a>,\n<a>shelf/shelf-io.serve.port</a>, and <a>shelf/shelf-io.serve.backlog</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpServer","inner":[]}]}],"parameters":{"handler":{"name":"handler","optional":false,"named":false,"default":false,"type":[{"outer":"shelf/shelf-typedef.Handler","inner":[]}],"value":null,"annotations":[]},"address":{"name":"address","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"backlog":{"name":"backlog","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"serveRequests":{"name":"serveRequests","qualifiedName":"shelf/shelf-io.serveRequests","comment":"<p>Serve a <a>shelf/dart-async.Stream</a> of <a>shelf/dart-io.HttpRequest</a>s.</p>\n<p><a>shelf/dart-io.HttpServer</a> implements Stream&lt;HttpRequest> so it can be passed directly\nto <a>shelf/shelf-io.serveRequests</a>.</p>\n<p>Errors thrown by <a>shelf/shelf-io.serveRequests.handler</a> while serving a request will be printed to the\nconsole and cause a 500 response with no body. Errors thrown asynchronously\nby <a>shelf/shelf-io.serveRequests.handler</a> will be printed to the console or, if there's an active error\nzone, passed to that zone.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"requests":{"name":"requests","optional":false,"named":false,"default":false,"type":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-io.HttpRequest","inner":[]}]}],"value":null,"annotations":[]},"handler":{"name":"handler","optional":false,"named":false,"default":false,"type":[{"outer":"shelf/shelf-typedef.Handler","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[],"typedef":{},"error":[]},"packageName":"shelf","packageIntro":"<h2>Web Server Middleware for Dart</h2>\n<h2>Introduction</h2>\n<p><strong>Shelf</strong> makes it easy to create and compose <strong>web servers</strong> and <strong>parts of web\nservers</strong>. How?</p><ul><li>Expose a small set of simple types.</li><li>\n<p>Map server logic into a simple function: a single argument for the request,\nthe response is the return value.</p></li><li>Trivially mix and match synchronous and asynchronous processing.</li><li>Flexibliity to return a simple string or a byte stream with the same model.</li></ul>\n<h2>Example</h2>\n<p>See <code>example/example_server.dart</code></p>\n<pre class=\"dart\"><code>import 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart' as io;\n\nvoid main() {\n  var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())\n      .addHandler(_echoRequest);\n\n  io.serve(handler, 'localhost', 8080).then((server) {\n    print('Serving at http://${server.address.host}:${server.port}');\n  });\n}\n\nshelf.Response _echoRequest(shelf.Request request) {\n  return new shelf.Response.ok('Request for \"${request.url}\"');\n}\n</code></pre>\n<h2>Handlers and Middleware</h2>\n<p>A <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Handler\">handler</a> is any function that handles a <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Request\">shelf.Request</a> and returns a\n<a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Response\">shelf.Response</a>. It can either handle the request itself--for example, a\nstatic file server that looks up the requested URI on the filesystem--or it can\ndo some processing and forward it to another handler--for example, a logger that\nprints information about requests and responses to the command line.</p>\n<p>The latter kind of handler is called \"<a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Middleware\">middleware</a>\", since it sits in the\nmiddle of the server stack. Middleware can be thought of as a function that\ntakes a handler and wraps it in another handler to provide additional\nfunctionality. A Shelf application is usually composed of many layers of\nmiddleware with one or more handlers at the very center; the <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Pipeline\">shelf.Pipeline</a>\nclass makes this sort of application easy to construct.</p>\n<p>Some middleware can also take multiple handlers and call one or more of them for\neach request. For example, a routing middleware might choose which handler to\ncall based on the request's URI or HTTP method, while a cascading middleware\nmight call each one in sequence until one returns a successful response.</p>\n<h2>Adapters</h2>\n<p>An adapter is any code that creates <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Request\">shelf.Request</a> objects, passes them to a\nhandler, and deals with the resulting <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Response\">shelf.Response</a>. For the most part,\nadapters forward requests from and responses to an underlying HTTP server;\n<a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf-io#id_serve\">shelf_io.serve</a> is this sort of adapter. An adapter might also synthesize\nHTTP requests within the browser using <code>window.location</code> and <code>window.history</code>,\nor it might pipe requests directly from an HTTP client to a Shelf handler.</p>\n<p>When implementing an adapter, some rules must be followed. The adapter must not\npass the <code>url</code> or <code>scriptName</code> parameters to <a href=\"https://api.dartlang.org/apidocs/channels/be/dartdoc-viewer/shelf/shelf.Request#id_Request-\">new shelf.Request</a>; it should\nonly pass <code>requestedUri</code>. If it passes the <code>context</code> parameter, all keys must\nbegin with the adapter's package name followed by a period. If multiple headers\nwith the same name are received, the adapter must collapse them into a single\nheader separated by commas as per <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html\">RFC 2616 section 4.2</a>.</p>\n<p>An adapter must handle all errors from the handler, including the handler\nreturning a <code>null</code> response. It should print each error to the console if\npossible, then act as though the handler returned a 500 response. The adapter\nmay include body data for the 500 response, but this body data must not include\ninformation about the error that occurred. This ensures that unexpected errors\ndon't result in exposing internal information in production by default; if the\nuser wants to return detailed error descriptions, they should explicitly include\nmiddleware to do so.</p>\n<p>An adapter should include information about itself in the Server header of the\nresponse by default. If the handler returns a response with the Server header\nset, that must take precedence over the adapter's default header.</p>\n<p>An adapter should ensure that asynchronous errors thrown by the handler don't\ncause the application to crash, even if they aren't reported by the future\nchain. Specifically, these errors shouldn't be passed to the root zone's error\nhandler; however, if the adapter is run within another error zone, it should\nallow these errors to be passed to that zone. The following function can be used\nto capture only errors that would otherwise be top-leveled:</p>\n<pre class=\"dart\"><code>/// Run [callback] and capture any errors that would otherwise be top-leveled.\n///\n/// If [this] is called in a non-root error zone, it will just run [callback]\n/// and return the result. Otherwise, it will capture any errors using\n/// [runZoned] and pass them to [onError].\ncatchTopLevelErrors(callback(), void onError(error, StackTrace stackTrace)) {\n  if (Zone.current.inSameErrorZone(Zone.ROOT)) {\n    return runZoned(callback, onError: onError);\n  } else {\n    return callback();\n  }\n}\n</code></pre>\n<h2>Inspiration</h2><ul><li>\n<p><a href=\"http://www.senchalabs.org/connect/\">Connect</a> for NodeJS.\n* Read <a href=\"http://howtonode.org/connect-it\">this great write-up</a> to understand\n  the overall philosophy of all of these models.</p></li><li><a href=\"http://rack.github.io/\">Rack</a> for Ruby.</li><li><a href=\"http://legacy.python.org/dev/peps/pep-3333/\">WSGI</a> for Python.</li></ul>"}