{"name":"scheduled_test","qualifiedName":"scheduled_test/scheduled_test","comment":"<p>A package for writing readable tests of asynchronous behavior.</p>\n<h2>Installing</h2>\n<p>Use <a href=\"http://pub.dartlang.org\">pub</a> to install this package. Add the following to your\n<code>pubspec.yaml</code> file.</p>\n<pre><code>dependencies:\n  scheduled_test: any\n</code></pre>\n<p>Then run <code>pub install</code>.</p>\n<p>For more information, see the\n<a href=\"http://pub.dartlang.org/packages/scheduled_test\">scheduled_test package on pub.dartlang.org</a>.</p>\n<p>This package works by building up a queue of asynchronous tasks called a\n\"schedule\", then executing those tasks in order. This allows the tests to\nread like synchronous, linear code, despite executing asynchronously.</p>\n<p>The <code>scheduled_test</code> package is built on top of <code>unittest</code>, and should be\nimported instead of <code>unittest</code>. It provides its own version of <a>scheduled_test/scheduled_test.group</a>,\n<a>scheduled_test/scheduled_test.test</a>, and <a>scheduled_test/scheduled_test.setUp</a>, and re-exports most other APIs from unittest.</p>\n<p>To schedule a task, call the <a>scheduled_test/scheduled_test.schedule</a> function. For example:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  test('writing to a file and reading it back should work', () {\n    schedule(() {\n      // The schedule won't proceed until the returned Future has\n      // completed.\n      return new File(\"output.txt\").writeAsString(\"contents\");\n    });\n\n    schedule(() {\n      return new File(\"output.txt\").readAsString().then((contents) {\n        // The normal unittest matchers can still be used.\n        expect(contents, equals(\"contents\"));\n      });\n    });\n  });\n}\n</code></pre>\n<h2>Setting up and tearing down</h2>\n<p>The <code>scheduled_test</code> package defines its own <a>scheduled_test/scheduled_test.setUp</a> method that works just\nlike the one in <code>unittest</code>. Tasks can be scheduled in <a>scheduled_test/scheduled_test.setUp</a>; they'll be\nrun before the tasks scheduled by tests in that group. <a>scheduled_test/scheduled_test.currentSchedule</a> is\nalso set in the <a>scheduled_test/scheduled_test.setUp</a> callback.</p>\n<p>This package doesn't have an explicit <code>tearDown</code> method. Instead, the\ncurrentSchedule.onComplete and currentSchedule.onException task queues\ncan have tasks scheduled during <a>scheduled_test/scheduled_test.setUp</a>. For example:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  var tempDir;\n  setUp(() {\n    schedule(() {\n      return createTempDir().then((dir) {\n        tempDir = dir;\n      });\n    });\n\n    currentSchedule.onComplete.schedule(() =&gt; deleteDir(tempDir));\n  });\n\n  // ...\n}\n</code></pre>\n<h2>Passing values between tasks</h2>\n<p>It's often useful to use values computed in one task in other tasks that are\nscheduled afterwards. There are two ways to do this. The most\nstraightforward is just to define a local variable and assign to it. For\nexample:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  test('computeValue returns 12', () {\n    var value;\n\n    schedule(() {\n      return computeValue().then((computedValue) {\n        value = computedValue;\n      });\n    });\n\n    schedule(() =&gt; expect(value, equals(12)));\n  });\n}\n</code></pre>\n<p>However, this doesn't scale well, especially when you start factoring out\ncalls to <a>scheduled_test/scheduled_test.schedule</a> into library methods. For that reason, <a>scheduled_test/scheduled_test.schedule</a>\nreturns a <a>scheduled_test/dart-async.Future</a> that will complete to the same value as the return\nvalue of the task. For example:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  test('computeValue returns 12', () {\n    var valueFuture = schedule(() =&gt; computeValue());\n    schedule(() {\n      valueFuture.then((value) =&gt; expect(value, equals(12)));\n    });\n  });\n}\n</code></pre>\n<h2>Out-of-Band Callbacks</h2>\n<p>Sometimes your tests will have callbacks that don't fit into the schedule.\nIt's important that errors in these callbacks are still registered, though,\nand that <a>scheduled_test/scheduled_test.Schedule.onException</a> and <a>scheduled_test/scheduled_test.Schedule.onComplete</a> still run after\nthey finish. When using <code>unittest</code>, you wrap these callbacks with\n<code>expectAsyncN</code>; when using <code>scheduled_test</code>, you use wrapAsync or\n<a>scheduled_test/scheduled_test.wrapFuture</a>.</p>\n<p>wrapAsync has two important functions. First, any errors that occur in it\nwill be passed into the <a>scheduled_test/scheduled_test.Schedule</a> instead of causing the whole test to\ncrash. They can then be handled by <a>scheduled_test/scheduled_test.Schedule.onException</a> and\n<a>scheduled_test/scheduled_test.Schedule.onComplete</a>. Second, a task queue isn't considered finished until\nall of its wrapAsync-wrapped functions have been called. This ensures that\n<a>scheduled_test/scheduled_test.Schedule.onException</a> and <a>scheduled_test/scheduled_test.Schedule.onComplete</a> will always run after all\nthe test code in the main queue.</p>\n<p>Note that the completes, completion, and throws matchers use\nwrapAsync internally, so they're safe to use in conjunction with scheduled\ntests.</p>\n<p>Here's an example of a test using wrapAsync to catch errors thrown in the\ncallback of a fictional <code>startServer</code> function:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  test('sendRequest sends a request', () {\n    startServer(wrapAsync((request) {\n      expect(request.body, equals('payload'));\n      request.response.close();\n    }));\n\n    schedule(() =&gt; sendRequest('payload'));\n  });\n}\n</code></pre>\n<p><a>scheduled_test/scheduled_test.wrapFuture</a> works similarly to wrapAsync, but instead of wrapping a\nsingle callback it wraps a whole <a>scheduled_test/dart-async.Future</a> chain. Like wrapAsync, it\nensures that the task queue doesn't complete until the out-of-band chain has\nfinished, and that any errors in the chain are piped back into the scheduled\ntest. For example:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  test('sendRequest sends a request', () {\n    wrapFuture(server.nextRequest.then((request) {\n      expect(request.body, equals('payload'));\n      expect(request.headers['content-type'], equals('text/plain'));\n    }));\n\n    schedule(() =&gt; sendRequest('payload'));\n  });\n}\n</code></pre>\n<h2>Timeouts</h2>\n<p><code>scheduled_test</code> has a built-in timeout of 5 seconds (configurable via\n<a>scheduled_test/scheduled_test.Schedule.timeout</a>). This timeout is aware of the structure of the schedule;\nthis means that it will reset for each task in a queue, when moving between\nqueues, or almost any other sort of interaction with <a>scheduled_test/scheduled_test.currentSchedule</a>. As\nlong as the <a>scheduled_test/scheduled_test.Schedule</a> knows your test is making some sort of progress, it\nwon't time out.</p>\n<p>If a single task might take a long time, you can also manually tell the\n<a>scheduled_test/scheduled_test.Schedule</a> that it's making progress by calling <a>scheduled_test/scheduled_test.Schedule.heartbeat</a>, which\nwill reset the timeout whenever it's called.</p>","variables":{"BREATH_INTERVAL":{"name":"BREATH_INTERVAL","qualifiedName":"scheduled_test/scheduled_test.BREATH_INTERVAL","comment":"<p>Interval (in msecs) after which synchronous tests will insert an async\ndelay to allow DOM or other updates.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]},"ERROR":{"name":"ERROR","qualifiedName":"scheduled_test/scheduled_test.ERROR","comment":"<p>Result string for an test case with an error.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"FAIL":{"name":"FAIL","qualifiedName":"scheduled_test/scheduled_test.FAIL","comment":"<p>Result string for a failing test case.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"PASS":{"name":"PASS","qualifiedName":"scheduled_test/scheduled_test.PASS","comment":"<p>Result string for a passing test case.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"anything":{"name":"anything","qualifiedName":"matcher/matcher.anything","comment":"<p>A matcher that matches any value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"completes":{"name":"completes","qualifiedName":"scheduled_test/scheduled_test.completes","comment":"<p>Matches a <a>scheduled_test/dart-async.Future</a> that completes successfully with a value. Note that this\ncreates an asynchronous expectation. The call to <code>expect()</code> that includes\nthis will return immediately and execution will continue. Later, when the\nfuture completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>matcher/matcher.throws</a> and\n<a>matcher/matcher.throwsA</a>.</p>\n<p>This differs from the <code>completes</code> matcher in <code>unittest</code> in that it pipes any\nerrors in the Future to <a>scheduled_test/scheduled_test.currentSchedule</a>, rather than reporting them in the\n<a>matcher/matcher.expect</a>'s error message.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"annotations":[]},"filterStacks":{"name":"filterStacks","qualifiedName":"scheduled_test/scheduled_test.filterStacks","comment":"<p>A flag that controls whether we try to filter out irrelevant frames from\nthe stack trace. Requires formatStacks to be set.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]},"formatStacks":{"name":"formatStacks","qualifiedName":"scheduled_test/scheduled_test.formatStacks","comment":"<p>A flag that controls whether we hide unittest and core library details in\nexception stacks.</p>\n<p>Useful to disable when debugging unittest or matcher customizations.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]},"groupSep":{"name":"groupSep","qualifiedName":"scheduled_test/scheduled_test.groupSep","comment":"<p>Separator used between group names and test names.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"isAbstractClassInstantiationError":{"name":"isAbstractClassInstantiationError","qualifiedName":"matcher/matcher.isAbstractClassInstantiationError","comment":"<p>A matcher for AbstractClassInstantiationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isArgumentError":{"name":"isArgumentError","qualifiedName":"matcher/matcher.isArgumentError","comment":"<p>A matcher for ArgumentErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isConcurrentModificationError":{"name":"isConcurrentModificationError","qualifiedName":"matcher/matcher.isConcurrentModificationError","comment":"<p>A matcher for ConcurrentModificationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isCyclicInitializationError":{"name":"isCyclicInitializationError","qualifiedName":"matcher/matcher.isCyclicInitializationError","comment":"<p>A matcher for CyclicInitializationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isEmpty":{"name":"isEmpty","qualifiedName":"matcher/matcher.isEmpty","comment":"<p>Returns a matcher that matches empty strings, maps or iterables\n(including collections).</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isException":{"name":"isException","qualifiedName":"matcher/matcher.isException","comment":"<p>A matcher for Exceptions.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isFallThroughError":{"name":"isFallThroughError","qualifiedName":"matcher/matcher.isFallThroughError","comment":"<p>A matcher for FallThroughError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isFalse":{"name":"isFalse","qualifiedName":"matcher/matcher.isFalse","comment":"<p>A matcher that matches anything except the Boolean value true.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isFormatException":{"name":"isFormatException","qualifiedName":"matcher/matcher.isFormatException","comment":"<p>A matcher for FormatExceptions.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isList":{"name":"isList","qualifiedName":"matcher/matcher.isList","comment":"<p>A matcher for List types.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isMap":{"name":"isMap","qualifiedName":"matcher/matcher.isMap","comment":"<p>A matcher for Map types.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isNegative":{"name":"isNegative","qualifiedName":"matcher/matcher.isNegative","comment":"<p>A matcher which matches if the match argument is negative.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNoSuchMethodError":{"name":"isNoSuchMethodError","qualifiedName":"matcher/matcher.isNoSuchMethodError","comment":"<p>A matcher for NoSuchMethodErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isNonNegative":{"name":"isNonNegative","qualifiedName":"matcher/matcher.isNonNegative","comment":"<p>A matcher which matches if the match argument is zero or positive.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNonPositive":{"name":"isNonPositive","qualifiedName":"matcher/matcher.isNonPositive","comment":"<p>A matcher which matches if the match argument is zero or negative.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNonZero":{"name":"isNonZero","qualifiedName":"matcher/matcher.isNonZero","comment":"<p>A matcher which matches if the match argument is non-zero.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNotNull":{"name":"isNotNull","qualifiedName":"matcher/matcher.isNotNull","comment":"<p>A matcher that matches any non-null value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNull":{"name":"isNull","qualifiedName":"matcher/matcher.isNull","comment":"<p>A matcher that matches any null value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNullThrownError":{"name":"isNullThrownError","qualifiedName":"matcher/matcher.isNullThrownError","comment":"<p>A matcher for NullThrownError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isPositive":{"name":"isPositive","qualifiedName":"matcher/matcher.isPositive","comment":"<p>A matcher which matches if the match argument is positive.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isRangeError":{"name":"isRangeError","qualifiedName":"matcher/matcher.isRangeError","comment":"<p>A matcher for RangeErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isStateError":{"name":"isStateError","qualifiedName":"matcher/matcher.isStateError","comment":"<p>A matcher for StateErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isTrue":{"name":"isTrue","qualifiedName":"matcher/matcher.isTrue","comment":"<p>A matcher that matches the Boolean value true.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isUnimplementedError":{"name":"isUnimplementedError","qualifiedName":"matcher/matcher.isUnimplementedError","comment":"<p>A matcher for UnimplementedErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isUnsupportedError":{"name":"isUnsupportedError","qualifiedName":"matcher/matcher.isUnsupportedError","comment":"<p>A matcher for UnsupportedError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isZero":{"name":"isZero","qualifiedName":"matcher/matcher.isZero","comment":"<p>A matcher which matches if the match argument is zero.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"returnsNormally":{"name":"returnsNormally","qualifiedName":"matcher/matcher.returnsNormally","comment":"<p>A matcher that matches a function call against no exception.\nThe function will be called once. Any exceptions will be silently swallowed.\nThe value passed to expect() should be a reference to the function.\nNote that the function cannot take arguments; to handle this\na wrapper will have to be created.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"testCases":{"name":"testCases","qualifiedName":"scheduled_test/scheduled_test.testCases","comment":"<p>Tests executed in this suite.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"scheduled_test/scheduled_test.TestCase","inner":[]}]}],"annotations":[]},"throws":{"name":"throws","qualifiedName":"matcher/matcher.throws","comment":"<p>This can be used to match two kinds of objects:</p><ul><li>\n<p>A <a>dart-core.Function</a> that throws an exception when called. The function cannot\ntake any arguments. If you want to test that a function expecting\narguments throws, wrap it in another zero-argument function that calls\nthe one you want to test.</p></li><li>\n<p>A <a>matcher/dart-async.Future</a> that completes with an exception. Note that this creates an\nasynchronous expectation. The call to <code>expect()</code> that includes this will\nreturn immediately and execution will continue. Later, when the future\ncompletes, the actual expectation will run.</p></li></ul>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsAbstractClassInstantiationError":{"name":"throwsAbstractClassInstantiationError","qualifiedName":"matcher/matcher.throwsAbstractClassInstantiationError","comment":"<p>A matcher for functions that throw AbstractClassInstantiationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsArgumentError":{"name":"throwsArgumentError","qualifiedName":"matcher/matcher.throwsArgumentError","comment":"<p>A matcher for functions that throw ArgumentError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsConcurrentModificationError":{"name":"throwsConcurrentModificationError","qualifiedName":"matcher/matcher.throwsConcurrentModificationError","comment":"<p>A matcher for functions that throw ConcurrentModificationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsCyclicInitializationError":{"name":"throwsCyclicInitializationError","qualifiedName":"matcher/matcher.throwsCyclicInitializationError","comment":"<p>A matcher for functions that throw CyclicInitializationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsException":{"name":"throwsException","qualifiedName":"matcher/matcher.throwsException","comment":"<p>A matcher for functions that throw Exception.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsFallThroughError":{"name":"throwsFallThroughError","qualifiedName":"matcher/matcher.throwsFallThroughError","comment":"<p>A matcher for functions that throw FallThroughError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsFormatException":{"name":"throwsFormatException","qualifiedName":"matcher/matcher.throwsFormatException","comment":"<p>A matcher for functions that throw FormatException.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsNoSuchMethodError":{"name":"throwsNoSuchMethodError","qualifiedName":"matcher/matcher.throwsNoSuchMethodError","comment":"<p>A matcher for functions that throw NoSuchMethodError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsNullThrownError":{"name":"throwsNullThrownError","qualifiedName":"matcher/matcher.throwsNullThrownError","comment":"<p>A matcher for functions that throw NullThrownError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsRangeError":{"name":"throwsRangeError","qualifiedName":"matcher/matcher.throwsRangeError","comment":"<p>A matcher for functions that throw RangeError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsStateError":{"name":"throwsStateError","qualifiedName":"matcher/matcher.throwsStateError","comment":"<p>A matcher for functions that throw StateError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsUnimplementedError":{"name":"throwsUnimplementedError","qualifiedName":"matcher/matcher.throwsUnimplementedError","comment":"<p>A matcher for functions that throw Exception.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsUnsupportedError":{"name":"throwsUnsupportedError","qualifiedName":"matcher/matcher.throwsUnsupportedError","comment":"<p>A matcher for functions that throw UnsupportedError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"wrapAsync":{"name":"wrapAsync","qualifiedName":"matcher/matcher.wrapAsync","comment":"<p>Some matchers, like those for Futures and exception testing,\ncan fail in asynchronous sections, and throw exceptions.\nA user of this library will typically want to catch and handle\nsuch exceptions. The <a>matcher/matcher.wrapAsync</a> property is a function that\ncan wrap callbacks used by these Matchers so that they can be\nused safely. For example, the unittest library will set this\nto be <code>expectAsync</code>. By default this is an identity function.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.Function","inner":[]}],"annotations":[]}},"functions":{"setters":{"unittestConfiguration=":{"name":"unittestConfiguration=","qualifiedName":"scheduled_test/scheduled_test.unittestConfiguration=","comment":"<p>Sets the <a>scheduled_test/scheduled_test.Configuration</a> used by the unittest library.</p>\n<p>Throws a <a>dart-core.StateError</a> if there is an existing, incompatible value.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"scheduled_test/scheduled_test.Configuration","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"getters":{"currentSchedule":{"name":"currentSchedule","qualifiedName":"scheduled_test/scheduled_test.currentSchedule","comment":"<p>The <a>scheduled_test/scheduled_test.Schedule</a> for the current test. This is used to add new tasks and\ninspect the state of the schedule.</p>\n<p>This is <code>null</code> when there's no test currently running.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Schedule","inner":[]}],"parameters":{},"annotations":[]},"currentTestCase":{"name":"currentTestCase","qualifiedName":"scheduled_test/scheduled_test.currentTestCase","comment":"<p><a>scheduled_test/scheduled_test.TestCase</a> currently being executed.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.TestCase","inner":[]}],"parameters":{},"annotations":[]},"unittestConfiguration":{"name":"unittestConfiguration","qualifiedName":"scheduled_test/scheduled_test.unittestConfiguration","comment":"<p><a>scheduled_test/scheduled_test.Configuration</a> used by the unittest library. Note that if a\nconfiguration has not been set, calling this getter will create\na default configuration.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Configuration","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{},"methods":{"addStateInfo":{"name":"addStateInfo","qualifiedName":"scheduled_test/scheduled_test.addStateInfo","comment":"<p>Useful utility for nesting match states.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"matchState":{"name":"matchState","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]},"values":{"name":"values","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"allOf":{"name":"allOf","qualifiedName":"scheduled_test/scheduled_test.allOf","comment":"<p>This returns a matcher that matches if all of the matchers passed as\narguments (up to 7) match. Instead of passing the matchers separately\nthey can be passed as a single List argument.\nAny argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"arg0":{"name":"arg0","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"arg1":{"name":"arg1","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg2":{"name":"arg2","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg3":{"name":"arg3","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg4":{"name":"arg4","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg5":{"name":"arg5","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg6":{"name":"arg6","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"anyElement":{"name":"anyElement","qualifiedName":"scheduled_test/scheduled_test.anyElement","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s in which at least one\nelement matches the given <a>scheduled_test/scheduled_test.anyElement.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"anyOf":{"name":"anyOf","qualifiedName":"scheduled_test/scheduled_test.anyOf","comment":"<p>Matches if any of the given matchers evaluate to true. The\narguments can be a set of matchers as separate parameters\n(up to 7), or a List of matchers.</p>\n<p>The matchers are evaluated from left to right using short-circuit\nevaluation, so evaluation stops as soon as a matcher returns true.</p>\n<p>Any argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"arg0":{"name":"arg0","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"arg1":{"name":"arg1","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg2":{"name":"arg2","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg3":{"name":"arg3","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg4":{"name":"arg4","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg5":{"name":"arg5","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg6":{"name":"arg6","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"closeTo":{"name":"closeTo","qualifiedName":"scheduled_test/scheduled_test.closeTo","comment":"<p>Returns a matcher which matches if the match argument is within <a>scheduled_test/scheduled_test.closeTo.delta</a>\nof some <a>scheduled_test/scheduled_test.closeTo.value</a>; i.e. if the match argument is greater than\nthan or equal <a>scheduled_test/scheduled_test.closeTo.value</a>-<a>scheduled_test/scheduled_test.closeTo.delta</a> and less than or equal to <a>scheduled_test/scheduled_test.closeTo.value</a>+<a>scheduled_test/scheduled_test.closeTo.delta</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"delta":{"name":"delta","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"collapseWhitespace":{"name":"collapseWhitespace","qualifiedName":"scheduled_test/scheduled_test.collapseWhitespace","comment":"<p>Utility function to collapse whitespace runs to single spaces\nand strip leading/trailing whitespace.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"_string":{"name":"_string","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"completion":{"name":"completion","qualifiedName":"scheduled_test/scheduled_test.completion","comment":"<p>Matches a <a>scheduled_test/dart-async.Future</a> that completes succesfully with a value that matches\n<a>scheduled_test/scheduled_test.completion.matcher</a>. Note that this creates an asynchronous expectation. The call to\n<code>expect()</code> that includes this will return immediately and execution will\ncontinue. Later, when the future completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>scheduled_test/matcher.throws</a> and\n<a>scheduled_test/scheduled_test.throwsA</a>.</p>\n<p><a>scheduled_test/scheduled_test.completion.description</a> is an optional tag that can be used to identify the completion\nmatcher in error messages.</p>\n<p>This differs from the <code>completion</code> matcher in <code>unittest</code> in that it pipes\nany errors in the Future to <a>scheduled_test/scheduled_test.currentSchedule</a>, rather than reporting them in\nthe <a>scheduled_test/scheduled_test.expect</a>'s error message.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"description":{"name":"description","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"configureExpectFailureHandler":{"name":"configureExpectFailureHandler","qualifiedName":"scheduled_test/scheduled_test.configureExpectFailureHandler","comment":"<p>Changes or resets to the default the failure handler for expect()\n<a>scheduled_test/scheduled_test.configureExpectFailureHandler.handler</a> is a reference to the new handler; if this is omitted\nor null then the failure handler is reset to the default, which\nthrows <a>scheduled_test/scheduled_test.TestFailure</a>s on <a>scheduled_test/scheduled_test.expect</a> assertion failures.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"handler":{"name":"handler","optional":true,"named":false,"default":true,"type":[{"outer":"scheduled_test/scheduled_test.FailureHandler","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"configureExpectFormatter":{"name":"configureExpectFormatter","qualifiedName":"scheduled_test/scheduled_test.configureExpectFormatter","comment":"<p>Changes or resets to default the failure message formatter for expect().\n<a>scheduled_test/scheduled_test.configureExpectFormatter.formatter</a> is a reference to the new formatter; if this is omitted or\nnull then the failure formatter is reset to the default. The new\nformatter is returned; this allows custom expect handlers to easily\nget a reference to the default formatter.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.ErrorFormatter","inner":[]}],"parameters":{"formatter":{"name":"formatter","optional":true,"named":false,"default":true,"type":[{"outer":"scheduled_test/scheduled_test.ErrorFormatter","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"contains":{"name":"contains","qualifiedName":"scheduled_test/scheduled_test.contains","comment":"<p>Returns a matcher that matches if the match argument contains\nthe expected value. For <a>dart-core.String</a>s this means substring matching;\nfor <a>dart-core.Map</a>s it means the map has the key, and for <a>dart-core.Iterable</a>s\n(including <a>dart-core.Iterable</a>s) it means the iterable has a matching\nelement. In the case of iterables, <a>scheduled_test/scheduled_test.contains.expected</a> can itself be a\nmatcher.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"containsPair":{"name":"containsPair","qualifiedName":"scheduled_test/scheduled_test.containsPair","comment":"<p>Returns a matcher which matches maps containing the key-value pair\nwith <a>scheduled_test/scheduled_test.containsPair.key</a> => <a>scheduled_test/scheduled_test.containsPair.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"key":{"name":"key","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"containsValue":{"name":"containsValue","qualifiedName":"scheduled_test/scheduled_test.containsValue","comment":"<p>Returns a matcher which matches maps containing the given <a>scheduled_test/scheduled_test.containsValue.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"disableTest":{"name":"disableTest","qualifiedName":"scheduled_test/scheduled_test.disableTest","comment":"<p>Disable a test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testId":{"name":"testId","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"enableTest":{"name":"enableTest","qualifiedName":"scheduled_test/scheduled_test.enableTest","comment":"<p>Enable a test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testId":{"name":"testId","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"endsWith":{"name":"endsWith","qualifiedName":"scheduled_test/scheduled_test.endsWith","comment":"<p>Returns a matcher that matches if the match argument is a string and\nends with <a>scheduled_test/scheduled_test.endsWith.suffixString</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"suffixString":{"name":"suffixString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"ensureInitialized":{"name":"ensureInitialized","qualifiedName":"scheduled_test/scheduled_test.ensureInitialized","comment":"<p>Lazily initializes the test library if not already initialized.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"equals":{"name":"equals","qualifiedName":"scheduled_test/scheduled_test.equals","comment":"<p>Returns a matcher that matches if the value is structurally equal to\n<a>scheduled_test/scheduled_test.equals.expected</a>.</p>\n<p>If <a>scheduled_test/scheduled_test.equals.expected</a> is a <a>scheduled_test/scheduled_test.Matcher</a>, then it matches using that. Otherwise it tests\nfor equality using <code>==</code> on the expected value.</p>\n<p>For <a>dart-core.Iterable</a>s and <a>dart-core.Map</a>s, this will recursively match the elements. To\nhandle cyclic structures a recursion depth <a>scheduled_test/scheduled_test.equals.limit</a> can be provided. The\ndefault limit is 100.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"limit":{"name":"limit","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"100","annotations":[]}},"annotations":[]},"equalsIgnoringCase":{"name":"equalsIgnoringCase","qualifiedName":"scheduled_test/scheduled_test.equalsIgnoringCase","comment":"<p>Returns a matcher which matches if the match argument is a string and\nis equal to <a>scheduled_test/scheduled_test.equalsIgnoringCase.value</a> when compared case-insensitively.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"equalsIgnoringWhitespace":{"name":"equalsIgnoringWhitespace","qualifiedName":"scheduled_test/scheduled_test.equalsIgnoringWhitespace","comment":"<p>Returns a matcher which matches if the match argument is a string and\nis equal to value when compared with all runs of whitespace\ncollapsed to single spaces and leading and trailing whitespace removed.</p>\n<p>For example, <code>equalsIgnoringCase(\"hello world\")</code> will match\n\"hello   world\", \"  hello world\" and \"hello world  \".</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"_string":{"name":"_string","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"everyElement":{"name":"everyElement","qualifiedName":"scheduled_test/scheduled_test.everyElement","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s in which all elements\nmatch the given <a>scheduled_test/scheduled_test.everyElement.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"expect":{"name":"expect","qualifiedName":"scheduled_test/scheduled_test.expect","comment":"<p>This is the main assertion function. It asserts that <a>scheduled_test/scheduled_test.expect.actual</a>\nmatches the <a>scheduled_test/scheduled_test.expect.matcher</a>. <a>scheduled_test/scheduled_test.expect.reason</a> is optional and is typically not\nsupplied, as a reason is generated from the matcher; if <a>scheduled_test/scheduled_test.expect.reason</a>\nis included it is appended to the reason generated by the matcher.</p>\n<p><a>scheduled_test/scheduled_test.expect.matcher</a> can be a value in which case it will be wrapped in an\n<a>scheduled_test/scheduled_test.equals</a> matcher.</p>\n<p>If the assertion fails, then the default behavior is to throw a\n<a>scheduled_test/scheduled_test.TestFailure</a>, but this behavior can be changed by calling\n<a>scheduled_test/scheduled_test.configureExpectFailureHandler</a> and providing an alternative handler that\nimplements the IFailureHandler interface. It is also possible to\npass a <a>scheduled_test/scheduled_test.expect.failureHandler</a> to <a>scheduled_test/scheduled_test.expect</a> as a final parameter for fine-\ngrained control.</p>\n<p>In some cases extra diagnostic info can be produced on failure (for\nexample, stack traces on mismatched exceptions). To enable these,\n<a>scheduled_test/scheduled_test.expect.verbose</a> should be specified as true;</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"actual":{"name":"actual","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"reason":{"name":"reason","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"failureHandler":{"name":"failureHandler","optional":true,"named":true,"default":false,"type":[{"outer":"scheduled_test/scheduled_test.FailureHandler","inner":[]}],"value":null,"annotations":[]},"verbose":{"name":"verbose","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"expectAsync":{"name":"expectAsync","qualifiedName":"scheduled_test/scheduled_test.expectAsync","comment":"<p>Indicate that <a>scheduled_test/scheduled_test.expectAsync.callback</a> is expected to be called a <a>scheduled_test/scheduled_test.expectAsync.count</a> number of times\n(by default 1). The unittest framework will wait for the callback to run the\nspecified <a>scheduled_test/scheduled_test.expectAsync.count</a> times before it continues with the following test.  Using\n<a>scheduled_test/scheduled_test.expectAsync</a> will also ensure that errors that occur within <a>scheduled_test/scheduled_test.expectAsync.callback</a> are\ntracked and reported. <a>scheduled_test/scheduled_test.expectAsync.callback</a> should take 0 positional arguments (named\narguments are not supported). <a>scheduled_test/scheduled_test.expectAsync.id</a> can be used to provide more\ndescriptive error messages if the callback is called more often than\nexpected. <a>scheduled_test/scheduled_test.expectAsync.max</a> can be used to specify an upper bound on the number of\ncalls; if this is exceeded the test will fail (or be marked as in error if\nit was already complete). A value of 0 for <a>scheduled_test/scheduled_test.expectAsync.max</a> (the default) will set\nthe upper bound to the same value as <a>scheduled_test/scheduled_test.expectAsync.count</a>; i.e. the callback should be\ncalled exactly <a>scheduled_test/scheduled_test.expectAsync.count</a> times. A value of -1 for <a>scheduled_test/scheduled_test.expectAsync.max</a> will mean no upper\nbound.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"expectAsyncUntil":{"name":"expectAsyncUntil","qualifiedName":"scheduled_test/scheduled_test.expectAsyncUntil","comment":"<p>Indicate that <a>scheduled_test/scheduled_test.expectAsyncUntil.callback</a> is expected to be called until <a>scheduled_test/scheduled_test.expectAsyncUntil.isDone</a> returns\ntrue. The unittest framework check <a>scheduled_test/scheduled_test.expectAsyncUntil.isDone</a> after each callback and only\nwhen it returns true will it continue with the following test. Using\n<a>scheduled_test/scheduled_test.expectAsyncUntil</a> will also ensure that errors that occur within\n<a>scheduled_test/scheduled_test.expectAsyncUntil.callback</a> are tracked and reported. <a>scheduled_test/scheduled_test.expectAsyncUntil.callback</a> should take 0 positional\narguments (named arguments are not supported). <a>scheduled_test/scheduled_test.expectAsyncUntil.id</a> can be used to\nidentify the callback in error messages (for example if it is called\nafter the test case is complete).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{}}},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"fail":{"name":"fail","qualifiedName":"scheduled_test/scheduled_test.fail","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"failureHandler":{"name":"failureHandler","optional":true,"named":true,"default":false,"type":[{"outer":"scheduled_test/scheduled_test.FailureHandler","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"filterTests":{"name":"filterTests","qualifiedName":"scheduled_test/scheduled_test.filterTests","comment":"<p>Filter the tests. <a>scheduled_test/scheduled_test.filterTests.testFilter</a> can be a <a>dart-core.RegExp</a>, a <a>dart-core.String</a> or a\npredicate function. This is different to enabling/disabling tests\nin that it removes the tests completely.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testFilter":{"name":"testFilter","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"getOrCreateExpectFailureHandler":{"name":"getOrCreateExpectFailureHandler","qualifiedName":"scheduled_test/scheduled_test.getOrCreateExpectFailureHandler","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.FailureHandler","inner":[]}],"parameters":{},"annotations":[]},"greaterThan":{"name":"greaterThan","qualifiedName":"scheduled_test/scheduled_test.greaterThan","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan the given <a>scheduled_test/scheduled_test.greaterThan.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"greaterThanOrEqualTo":{"name":"greaterThanOrEqualTo","qualifiedName":"scheduled_test/scheduled_test.greaterThanOrEqualTo","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to the given <a>scheduled_test/scheduled_test.greaterThanOrEqualTo.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"group":{"name":"group","qualifiedName":"scheduled_test/scheduled_test.group","comment":"<p>Creates a new named group of tests. This has the same semantics as\n<a>scheduled_test/unittest.group</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}}},"annotations":[]},"handleExternalError":{"name":"handleExternalError","qualifiedName":"scheduled_test/scheduled_test.handleExternalError","comment":"<p>Handle errors that happen outside the tests.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"e":{"name":"e","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"stack":{"name":"stack","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"hasLength":{"name":"hasLength","qualifiedName":"scheduled_test/scheduled_test.hasLength","comment":"<p>Returns a matcher that matches if an object has a length property\nthat matches <a>scheduled_test/scheduled_test.hasLength.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inClosedOpenRange":{"name":"inClosedOpenRange","qualifiedName":"scheduled_test/scheduled_test.inClosedOpenRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to a <a>scheduled_test/scheduled_test.inClosedOpenRange.low</a> and less than <a>scheduled_test/scheduled_test.inClosedOpenRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inExclusiveRange":{"name":"inExclusiveRange","qualifiedName":"scheduled_test/scheduled_test.inExclusiveRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan <a>scheduled_test/scheduled_test.inExclusiveRange.low</a> and less than <a>scheduled_test/scheduled_test.inExclusiveRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inInclusiveRange":{"name":"inInclusiveRange","qualifiedName":"scheduled_test/scheduled_test.inInclusiveRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to <a>scheduled_test/scheduled_test.inInclusiveRange.low</a> and less than or equal to <a>scheduled_test/scheduled_test.inInclusiveRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inOpenClosedRange":{"name":"inOpenClosedRange","qualifiedName":"scheduled_test/scheduled_test.inOpenClosedRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan <a>scheduled_test/scheduled_test.inOpenClosedRange.low</a> and less than or equal to <a>scheduled_test/scheduled_test.inOpenClosedRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isIn":{"name":"isIn","qualifiedName":"scheduled_test/scheduled_test.isIn","comment":"<p>Returns a matcher that matches if the match argument is in\nthe expected value. This is the converse of <a>scheduled_test/scheduled_test.contains</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isNot":{"name":"isNot","qualifiedName":"scheduled_test/scheduled_test.isNot","comment":"<p>This returns a matcher that inverts <a>scheduled_test/scheduled_test.isNot.matcher</a> to its logical negation.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"lessThan":{"name":"lessThan","qualifiedName":"scheduled_test/scheduled_test.lessThan","comment":"<p>Returns a matcher which matches if the match argument is less\nthan the given <a>scheduled_test/scheduled_test.lessThan.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"lessThanOrEqualTo":{"name":"lessThanOrEqualTo","qualifiedName":"scheduled_test/scheduled_test.lessThanOrEqualTo","comment":"<p>Returns a matcher which matches if the match argument is less\nthan or equal to the given <a>scheduled_test/scheduled_test.lessThanOrEqualTo.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"logMessage":{"name":"logMessage","qualifiedName":"scheduled_test/scheduled_test.logMessage","comment":"<p>Can be called by tests to log status. Tests should use this\ninstead of <a>dart-core.print</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"matches":{"name":"matches","qualifiedName":"scheduled_test/scheduled_test.matches","comment":"<p>Returns a matcher that matches if the match argument is a string and\nmatches the regular expression given by <a>scheduled_test/scheduled_test.matches.re</a>. <a>scheduled_test/scheduled_test.matches.re</a> can be a RegExp\ninstance or a string; in the latter case it will be used to create\na RegExp instance.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"re":{"name":"re","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"orderedEquals":{"name":"orderedEquals","qualifiedName":"scheduled_test/scheduled_test.orderedEquals","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s that have the same\nlength and the same elements as <a>scheduled_test/scheduled_test.orderedEquals.expected</a>, and in the same order.\nThis is equivalent to equals but does not recurse.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"pairwiseCompare":{"name":"pairwiseCompare","qualifiedName":"scheduled_test/scheduled_test.pairwiseCompare","comment":"<p>A pairwise matcher for iterable. You can pass an arbitrary <a>scheduled_test/scheduled_test.pairwiseCompare.comparator</a>\nfunction that takes an expected and actual argument which will be applied\nto each pair in order. <a>scheduled_test/scheduled_test.pairwiseCompare.description</a>  should be a meaningful name for\nthe comparator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]},"comparator":{"name":"comparator","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"predicate":{"name":"predicate","qualifiedName":"scheduled_test/scheduled_test.predicate","comment":"<p>Returns a matcher that uses an arbitrary function that returns\ntrue or false for the actual value. For example:</p>\n<pre><code>expect(v, predicate((x) =&gt; ((x % 2) == 0), \"is even\"))\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"description":{"name":"description","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"\"satisfies function\"","annotations":[]}},"annotations":[]},"registerException":{"name":"registerException","qualifiedName":"scheduled_test/scheduled_test.registerException","comment":"<p>Registers that an exception was caught for the current test.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"e":{"name":"e","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"trace":{"name":"trace","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"runTests":{"name":"runTests","qualifiedName":"scheduled_test/scheduled_test.runTests","comment":"<p>Runs all queued tests, one at a time.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"same":{"name":"same","qualifiedName":"scheduled_test/scheduled_test.same","comment":"<p>Returns a matches that matches if the value is the same instance\nas <a>scheduled_test/scheduled_test.same.expected</a>, using <a>dart-core.identical</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"schedule":{"name":"schedule","qualifiedName":"scheduled_test/scheduled_test.schedule","comment":"<p>Schedules a task, <a>scheduled_test/scheduled_test.schedule.fn</a>, to run asynchronously as part of the main task queue\nof <a>scheduled_test/scheduled_test.currentSchedule</a>. Tasks will be run in the order they're scheduled. If\n<a>scheduled_test/scheduled_test.schedule.fn</a> returns a <a>scheduled_test/dart-async.Future</a>, tasks after it won't be run until that <a>scheduled_test/dart-async.Future</a>\ncompletes.</p>\n<p>The return value will be completed once the scheduled task has finished\nrunning. Its return value is the same as the return value of <a>scheduled_test/scheduled_test.schedule.fn</a>, or the\nvalue it completes to if it's a <a>scheduled_test/dart-async.Future</a>.</p>\n<p>If <a>scheduled_test/scheduled_test.schedule.description</a> is passed, it's used to describe the task for debugging\npurposes when an error occurs.</p>\n<p>If this is called when a task queue is currently running, it will run <a>scheduled_test/scheduled_test.schedule.fn</a>\non the next event loop iteration rather than adding it to a queue. The\ncurrent task will not complete until <a>scheduled_test/scheduled_test.schedule.fn</a> (and any <a>scheduled_test/dart-async.Future</a> it returns) has\nfinished running. Any errors in <a>scheduled_test/scheduled_test.schedule.fn</a> will automatically be handled.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}},"description":{"name":"description","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"setSoloTest":{"name":"setSoloTest","qualifiedName":"scheduled_test/scheduled_test.setSoloTest","comment":"<p>Select a solo test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"id":{"name":"id","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"setUp":{"name":"setUp","qualifiedName":"scheduled_test/scheduled_test.setUp","comment":"<p>Register a <a>scheduled_test/scheduled_test.setUp</a> function for a test <a>scheduled_test/scheduled_test.group</a>. This has the same semantics\nas <a>scheduled_test/unittest.setUp</a>. Tasks may be scheduled using <a>scheduled_test/scheduled_test.schedule</a> within\n<a>scheduled_test/scheduled_test.setUp.setUpFn</a>, and <a>scheduled_test/scheduled_test.currentSchedule</a> may be accessed as well.</p>\n<p>Note that there is no associated tearDown function. Instead, tasks should\nbe scheduled for currentSchedule.onComplete or\ncurrentSchedule.onException. These tasks will be run after each test's\nschedule is completed.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"setUpFn":{"name":"setUpFn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}}},"annotations":[]},"skip_group":{"name":"skip_group","qualifiedName":"scheduled_test/scheduled_test.skip_group","comment":"<p>Like <a>scheduled_test/scheduled_test.skip_test</a>, but for groups.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}}},"annotations":[]},"skip_test":{"name":"skip_test","qualifiedName":"scheduled_test/scheduled_test.skip_test","comment":"<p>Convenience function for skipping a test.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"spec":{"name":"spec","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"scheduled_test/scheduled_test.TestFunction","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"solo_group":{"name":"solo_group","qualifiedName":"scheduled_test/scheduled_test.solo_group","comment":"<p>Like <a>scheduled_test/unittest.solo_test</a>, but for groups.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}}},"annotations":[]},"solo_test":{"name":"solo_test","qualifiedName":"scheduled_test/scheduled_test.solo_test","comment":"<p>Creates a new test case with the given description and body that will be the\nonly test run in this file.</p>\n<p>This has the same semantics as <a>scheduled_test/unittest.solo_test</a>.</p>\n<p>If <a>scheduled_test/scheduled_test.solo_test.body</a> returns a <a>scheduled_test/dart-async.Future</a>, that future will automatically be wrapped with\n<a>scheduled_test/scheduled_test.wrapFuture</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}}},"annotations":[]},"startsWith":{"name":"startsWith","qualifiedName":"scheduled_test/scheduled_test.startsWith","comment":"<p>Returns a matcher that matches if the match argument is a string and\nstarts with <a>scheduled_test/scheduled_test.startsWith.prefixString</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"prefixString":{"name":"prefixString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"stringContainsInOrder":{"name":"stringContainsInOrder","qualifiedName":"scheduled_test/scheduled_test.stringContainsInOrder","comment":"<p>Returns a matcher that matches if the match argument is a string and\ncontains a given list of <a>scheduled_test/scheduled_test.stringContainsInOrder.substrings</a> in relative order.</p>\n<p>For example, <code>stringContainsInOrder([\"a\", \"e\", \"i\", \"o\", \"u\"])</code> will match\n\"abcdefghijklmnopqrstuvwxyz\".</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"substrings":{"name":"substrings","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"test":{"name":"test","qualifiedName":"scheduled_test/scheduled_test.test","comment":"<p>Creates a new test case with the given description and body.</p>\n<p>This has the same semantics as <a>scheduled_test/unittest.test</a>.</p>\n<p>If <a>scheduled_test/scheduled_test.test.body</a> returns a <a>scheduled_test/dart-async.Future</a>, that future will automatically be wrapped with\n<a>scheduled_test/scheduled_test.wrapFuture</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}}},"annotations":[]},"throwsA":{"name":"throwsA","qualifiedName":"scheduled_test/scheduled_test.throwsA","comment":"<p>This can be used to match two kinds of objects:</p><ul><li>\n<p>A <a>dart-core.Function</a> that throws an exception when called. The function cannot\ntake any arguments. If you want to test that a function expecting\narguments throws, wrap it in another zero-argument function that calls\nthe one you want to test.</p></li><li>\n<p>A <a>scheduled_test/dart-async.Future</a> that completes with an exception. Note that this creates an\nasynchronous expectation. The call to <code>expect()</code> that includes this will\nreturn immediately and execution will continue. Later, when the future\ncompletes, the actual expectation will run.</p></li></ul>\n<p>In both cases, when an exception is thrown, this will test that the exception\nobject matches <a>scheduled_test/scheduled_test.throwsA.matcher</a>. If <a>scheduled_test/scheduled_test.throwsA.matcher</a> is not an instance of <a>scheduled_test/scheduled_test.Matcher</a>, it\nwill implicitly be treated as <code>equals(matcher)</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"unorderedEquals":{"name":"unorderedEquals","qualifiedName":"scheduled_test/scheduled_test.unorderedEquals","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s that have the same\nlength and the same elements as <a>scheduled_test/scheduled_test.unorderedEquals.expected</a>, but not necessarily in\nthe same order. Note that this is O(n^2) so should only be used on\nsmall objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"unorderedMatches":{"name":"unorderedMatches","qualifiedName":"scheduled_test/scheduled_test.unorderedMatches","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s whose elements match the matchers\nin <a>scheduled_test/scheduled_test.unorderedMatches.expected</a>, but not necessarily in the same order.</p>\n<p> Note that this is <code>O(n^2)</code> and so should only be used on small objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"wrapFuture":{"name":"wrapFuture","qualifiedName":"scheduled_test/scheduled_test.wrapFuture","comment":"<p>Like wrapAsync, this ensures that the current task queue waits for\nout-of-band asynchronous code, and that errors raised in that code are\nhandled correctly. However, <a>scheduled_test/scheduled_test.wrapFuture</a> wraps a <a>scheduled_test/dart-async.Future</a> chain rather than\na single callback.</p>\n<p>The returned <a>scheduled_test/dart-async.Future</a> completes to the same value or error as <a>scheduled_test/scheduled_test.wrapFuture.future</a>.</p>\n<p><a>scheduled_test/scheduled_test.wrapFuture.description</a> provides an optional description of the future, which is\nused when generating error messages.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"future":{"name":"future","optional":false,"named":false,"default":false,"type":[{"outer":"dart-async.Future","inner":[]}],"value":null,"annotations":[]},"description":{"name":"description","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"wrapMatcher":{"name":"wrapMatcher","qualifiedName":"scheduled_test/scheduled_test.wrapMatcher","comment":"<p>Takes an argument and returns an equivalent matcher.\nIf the argument is already a matcher this does nothing,\nelse if the argument is a function, it generates a predicate\nfunction matcher, else it generates an equals matcher.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"x":{"name":"x","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"Configuration","qualifiedName":"scheduled_test/scheduled_test.Configuration","preview":"<p>Describes the interface used by the unit test system for communicating the\nresults of a test run.</p>"},{"name":"CustomMatcher","qualifiedName":"scheduled_test/scheduled_test.CustomMatcher","preview":"<p>A useful utility class for implementing other matchers through inheritance.\nDerived classes should call the base constructor with a feature name and\ndescription, and an instance matcher, and should implement the\n<a>scheduled_test/scheduled_test.CustomMatcher.featureValueOf</a> abstract method.</p>"},{"name":"DefaultFailureHandler","qualifiedName":"scheduled_test/scheduled_test.DefaultFailureHandler"},{"name":"Description","qualifiedName":"scheduled_test/scheduled_test.Description","preview":"<p>Matchers build up their error messages by appending to\nDescription objects. This interface is implemented by\nStringDescription. This interface is unlikely to need\nother implementations, but could be useful to replace in\nsome cases - e.g. language conversion.</p>"},{"name":"FailureHandler","qualifiedName":"scheduled_test/scheduled_test.FailureHandler","preview":"<p>Failed matches are reported using a default IFailureHandler.\nThe default implementation simply throws TestFailures;\nthis can be replaced by some other implementation of\nIFailureHandler by calling configureExpectHandler.</p>"},{"name":"Matcher","qualifiedName":"scheduled_test/scheduled_test.Matcher","preview":"<p>expect Matchers must implement/extend the Matcher class.\nThe base Matcher class has a generic implementation of <a>scheduled_test/scheduled_test.Matcher.describeMismatch</a>\nso this does not need to be provided unless a more clear description is\nrequired. The other two methods (<a>scheduled_test/scheduled_test.Matcher.matches</a> and <a>scheduled_test/scheduled_test.Matcher.describe</a>)\nmust always be provided as they are highly matcher-specific.</p>"},{"name":"PendingCallback","qualifiedName":"scheduled_test/scheduled_test.PendingCallback","preview":"<p>An identifier for an out-of-band callback running during a schedule.</p>"},{"name":"Schedule","qualifiedName":"scheduled_test/scheduled_test.Schedule","preview":"<p>The schedule of tasks to run for a single test. This has three separate task\nqueues: <a>scheduled_test/scheduled_test.Schedule.tasks</a>, <a>scheduled_test/scheduled_test.Schedule.onComplete</a>, and <a>scheduled_test/scheduled_test.Schedule.onException</a>. It also provides\nvisibility into the current state of the schedule.</p>"},{"name":"ScheduleError","qualifiedName":"scheduled_test/scheduled_test.ScheduleError","preview":"<p>A wrapper for errors that occur during a scheduled test.</p>"},{"name":"ScheduleState","qualifiedName":"scheduled_test/scheduled_test.ScheduleState","preview":"<p>An enum of states for a <a>scheduled_test/scheduled_test.Schedule</a>.</p>"},{"name":"SimpleConfiguration","qualifiedName":"scheduled_test/scheduled_test.SimpleConfiguration","preview":"<p>Hooks to configure the unittest library for different platforms. This class\nimplements the API in a platform-independent way. Tests that want to take\nadvantage of the platform can create a subclass and override methods from\nthis class.</p>"},{"name":"StringDescription","qualifiedName":"scheduled_test/scheduled_test.StringDescription","preview":"<p>The default implementation of IDescription. This should rarely need\nsubstitution, although conceivably it is a place where other languages\ncould be supported.</p>"},{"name":"Task","qualifiedName":"scheduled_test/scheduled_test.Task","preview":"<p>A single task to be run as part of a <a>scheduled_test/scheduled_test.TaskQueue</a>.</p>"},{"name":"TaskQueue","qualifiedName":"scheduled_test/scheduled_test.TaskQueue","preview":"<p>A queue of asynchronous tasks to execute in order.</p>"},{"name":"TaskState","qualifiedName":"scheduled_test/scheduled_test.TaskState","preview":"<p>An enum of states for a <a>scheduled_test/scheduled_test.Task</a>.</p>"},{"name":"TestCase","qualifiedName":"scheduled_test/scheduled_test.TestCase","preview":"<p>Represents the state for an individual unit test.</p>"},{"name":"Throws","qualifiedName":"scheduled_test/scheduled_test.Throws"},{"name":"TypeMatcher","qualifiedName":"scheduled_test/scheduled_test.TypeMatcher"},{"name":"isInstanceOf","qualifiedName":"scheduled_test/scheduled_test.isInstanceOf","preview":"<p>Returns a matcher that matches if an object is an instance\nof type (or a subtype).</p>"}],"typedef":{"ErrorFormatter":{"name":"ErrorFormatter","qualifiedName":"scheduled_test/scheduled_test.ErrorFormatter","comment":"<p>The ErrorFormatter type is used for functions that\ncan be used to build up error reports upon expect failures.\nThere is one built-in implementation (defaultErrorFormatter)\nwhich is used by the default failure handler. If the failure handler\nis replaced it may be desirable to replace the stringDescription\nerror formatter with another.</p>","return":"dart-core.String","parameters":{"actual":{"name":"actual","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"value":null,"annotations":[]},"reason":{"name":"reason","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"matchState":{"name":"matchState","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]},"verbose":{"name":"verbose","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.bool","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>The ErrorFormatter type is used for functions that\ncan be used to build up error reports upon expect failures.\nThere is one built-in implementation (defaultErrorFormatter)\nwhich is used by the default failure handler. If the failure handler\nis replaced it may be desirable to replace the stringDescription\nerror formatter with another.</p>"},"TaskBody":{"name":"TaskBody","qualifiedName":"scheduled_test/scheduled_test.TaskBody","comment":"","return":"dart-async.Future","parameters":{},"annotations":[],"generics":{}},"TestFunction":{"name":"TestFunction","qualifiedName":"scheduled_test/scheduled_test.TestFunction","comment":"<p>Signature for a test function.</p>","return":"dynamic","parameters":{},"annotations":[],"generics":{},"preview":"<p>Signature for a test function.</p>"}},"error":[{"name":"TestFailure","qualifiedName":"scheduled_test/scheduled_test.TestFailure","preview":"<p>The objects thrown by the default failure handler.</p>"}]},"packageName":"scheduled_test","packageIntro":""}