{"name":"scheduled_test","qualifiedName":"scheduled_test/scheduled_test","comment":"<p>A package for writing readable tests of asynchronous behavior.</p>\n<h2>Installing</h2>\n<p>Use <a href=\"http://pub.dartlang.org\">pub</a> to install this package. Add the following to your\n<code>pubspec.yaml</code> file.</p>\n<pre><code>dependencies:\n  scheduled_test: any\n</code></pre>\n<p>Then run <code>pub install</code>.</p>\n<p>For more information, see the\n<a href=\"http://pub.dartlang.org/packages/scheduled_test\">scheduled_test package on pub.dartlang.org</a>.</p>\n<p>This package works by building up a queue of asynchronous tasks called a\n\"schedule\", then executing those tasks in order. This allows the tests to\nread like synchronous, linear code, despite executing asynchronously.</p>\n<p>The <code>scheduled_test</code> package is built on top of <code>unittest</code>, and should be\nimported instead of <code>unittest</code>. It provides its own version of <a>scheduled_test/scheduled_test.group</a>,\n<a>scheduled_test/scheduled_test.test</a>, and <a>scheduled_test/scheduled_test.setUp</a>, and re-exports most other APIs from unittest.</p>\n<p>To schedule a task, call the <a>scheduled_test/scheduled_test.schedule</a> function. For example:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  test('writing to a file and reading it back should work', () {\n    schedule(() {\n      // The schedule won't proceed until the returned Future has\n      // completed.\n      return new File(\"output.txt\").writeAsString(\"contents\");\n    });\n\n    schedule(() {\n      return new File(\"output.txt\").readAsString().then((contents) {\n        // The normal unittest matchers can still be used.\n        expect(contents, equals(\"contents\"));\n      });\n    });\n  });\n}\n</code></pre>\n<h2>Setting up and tearing down</h2>\n<p>The <code>scheduled_test</code> package defines its own <a>scheduled_test/scheduled_test.setUp</a> method that works just\nlike the one in <code>unittest</code>. Tasks can be scheduled in <a>scheduled_test/scheduled_test.setUp</a>; they'll be\nrun before the tasks scheduled by tests in that group. <a>scheduled_test/scheduled_test.currentSchedule</a> is\nalso set in the <a>scheduled_test/scheduled_test.setUp</a> callback.</p>\n<p>This package doesn't have an explicit <code>tearDown</code> method. Instead, the\ncurrentSchedule.onComplete and currentSchedule.onException task queues\ncan have tasks scheduled during <a>scheduled_test/scheduled_test.setUp</a>. For example:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  var tempDir;\n  setUp(() {\n    schedule(() {\n      return createTempDir().then((dir) {\n        tempDir = dir;\n      });\n    });\n\n    currentSchedule.onComplete.schedule(() =&gt; deleteDir(tempDir));\n  });\n\n  // ...\n}\n</code></pre>\n<h2>Passing values between tasks</h2>\n<p>It's often useful to use values computed in one task in other tasks that are\nscheduled afterwards. There are two ways to do this. The most\nstraightforward is just to define a local variable and assign to it. For\nexample:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  test('computeValue returns 12', () {\n    var value;\n\n    schedule(() {\n      return computeValue().then((computedValue) {\n        value = computedValue;\n      });\n    });\n\n    schedule(() =&gt; expect(value, equals(12)));\n  });\n}\n</code></pre>\n<p>However, this doesn't scale well, especially when you start factoring out\ncalls to <a>scheduled_test/scheduled_test.schedule</a> into library methods. For that reason, <a>scheduled_test/scheduled_test.schedule</a>\nreturns a <a>scheduled_test/dart-async.Future</a> that will complete to the same value as the return\nvalue of the task. For example:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  test('computeValue returns 12', () {\n    var valueFuture = schedule(() =&gt; computeValue());\n    schedule(() {\n      valueFuture.then((value) =&gt; expect(value, equals(12)));\n    });\n  });\n}\n</code></pre>\n<h2>Out-of-Band Callbacks</h2>\n<p>Sometimes your tests will have callbacks that don't fit into the schedule.\nIt's important that errors in these callbacks are still registered, though,\nand that <a>scheduled_test/scheduled_test.Schedule.onException</a> and <a>scheduled_test/scheduled_test.Schedule.onComplete</a> still run after\nthey finish. When using <code>unittest</code>, you wrap these callbacks with\n<code>expectAsyncN</code>; when using <code>scheduled_test</code>, you use wrapAsync or\n<a>scheduled_test/scheduled_test.wrapFuture</a>.</p>\n<p>wrapAsync has two important functions. First, any errors that occur in it\nwill be passed into the <a>scheduled_test/scheduled_test.Schedule</a> instead of causing the whole test to\ncrash. They can then be handled by <a>scheduled_test/scheduled_test.Schedule.onException</a> and\n<a>scheduled_test/scheduled_test.Schedule.onComplete</a>. Second, a task queue isn't considered finished until\nall of its wrapAsync-wrapped functions have been called. This ensures that\n<a>scheduled_test/scheduled_test.Schedule.onException</a> and <a>scheduled_test/scheduled_test.Schedule.onComplete</a> will always run after all\nthe test code in the main queue.</p>\n<p>Note that the completes, completion, and throws matchers use\nwrapAsync internally, so they're safe to use in conjunction with scheduled\ntests.</p>\n<p>Here's an example of a test using wrapAsync to catch errors thrown in the\ncallback of a fictional <code>startServer</code> function:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  test('sendRequest sends a request', () {\n    startServer(wrapAsync((request) {\n      expect(request.body, equals('payload'));\n      request.response.close();\n    }));\n\n    schedule(() =&gt; sendRequest('payload'));\n  });\n}\n</code></pre>\n<p><a>scheduled_test/scheduled_test.wrapFuture</a> works similarly to wrapAsync, but instead of wrapping a\nsingle callback it wraps a whole <a>scheduled_test/dart-async.Future</a> chain. Like wrapAsync, it\nensures that the task queue doesn't complete until the out-of-band chain has\nfinished, and that any errors in the chain are piped back into the scheduled\ntest. For example:</p>\n<pre><code>import 'package:scheduled_test/scheduled_test.dart';\n\nvoid main() {\n  test('sendRequest sends a request', () {\n    wrapFuture(server.nextRequest.then((request) {\n      expect(request.body, equals('payload'));\n      expect(request.headers['content-type'], equals('text/plain'));\n    }));\n\n    schedule(() =&gt; sendRequest('payload'));\n  });\n}\n</code></pre>\n<h2>Timeouts</h2>\n<p><code>scheduled_test</code> has a built-in timeout of 5 seconds (configurable via\n<a>scheduled_test/scheduled_test.Schedule.timeout</a>). This timeout is aware of the structure of the schedule;\nthis means that it will reset for each task in a queue, when moving between\nqueues, or almost any other sort of interaction with <a>scheduled_test/scheduled_test.currentSchedule</a>. As\nlong as the <a>scheduled_test/scheduled_test.Schedule</a> knows your test is making some sort of progress, it\nwon't time out.</p>\n<p>If a single task might take a long time, you can also manually tell the\n<a>scheduled_test/scheduled_test.Schedule</a> that it's making progress by calling <a>scheduled_test/scheduled_test.Schedule.heartbeat</a>, which\nwill reset the timeout whenever it's called.</p>","variables":{"filterStacks":{"name":"filterStacks","qualifiedName":"scheduled_test/scheduled_test.filterStacks","comment":"<p>A flag that controls whether we try to filter out irrelevant frames from\nthe stack trace. Requires formatStacks to be set.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]},"formatStacks":{"name":"formatStacks","qualifiedName":"scheduled_test/scheduled_test.formatStacks","comment":"<p>A flag that controls whether we hide unittest and core library details in\nexception stacks.</p>\n<p>Useful to disable when debugging unittest or matcher customizations.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]},"ERROR":{"name":"ERROR","qualifiedName":"scheduled_test/scheduled_test.ERROR","comment":"<p>Result string for an test case with an error.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"FAIL":{"name":"FAIL","qualifiedName":"scheduled_test/scheduled_test.FAIL","comment":"<p>Result string for a failing test case.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"PASS":{"name":"PASS","qualifiedName":"scheduled_test/scheduled_test.PASS","comment":"<p>Result string for a passing test case.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"BREATH_INTERVAL":{"name":"BREATH_INTERVAL","qualifiedName":"scheduled_test/scheduled_test.BREATH_INTERVAL","comment":"<p>Interval (in msecs) after which synchronous tests will insert an async\ndelay to allow DOM or other updates.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]},"testCases":{"name":"testCases","qualifiedName":"scheduled_test/scheduled_test.testCases","comment":"<p>Tests executed in this suite.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"scheduled_test/scheduled_test.TestCase","inner":[]}]}],"annotations":[]},"groupSep":{"name":"groupSep","qualifiedName":"scheduled_test/scheduled_test.groupSep","comment":"<p>Separator used between group names and test names.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"completes":{"name":"completes","qualifiedName":"scheduled_test/scheduled_test.completes","comment":"<p>Matches a <a>scheduled_test/dart-async.Future</a> that completes successfully with a value. Note that this\ncreates an asynchronous expectation. The call to <code>expect()</code> that includes\nthis will return immediately and execution will continue. Later, when the\nfuture completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>unittest/unittest-matcher.throws</a> and\n<a>unittest/unittest-matcher.throwsA</a>.</p>\n<p>This differs from the <code>completes</code> matcher in <code>unittest</code> in that it pipes any\nerrors in the Future to <a>scheduled_test/scheduled_test.currentSchedule</a>, rather than reporting them in the\n<a>unittest/unittest-matcher.expect</a>'s error message.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"annotations":[]}},"functions":{"setters":{"unittestConfiguration=":{"name":"unittestConfiguration=","qualifiedName":"scheduled_test/scheduled_test.unittestConfiguration=","comment":"<p>Sets the <a>scheduled_test/scheduled_test.Configuration</a> used by the unittest library.</p>\n<p>Throws a <a>dart-core.StateError</a> if there is an existing, incompatible value.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"scheduled_test/scheduled_test.Configuration","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"getters":{"currentTestCase":{"name":"currentTestCase","qualifiedName":"scheduled_test/scheduled_test.currentTestCase","comment":"<p><a>scheduled_test/scheduled_test.TestCase</a> currently being executed.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.TestCase","inner":[]}],"parameters":{},"annotations":[]},"unittestConfiguration":{"name":"unittestConfiguration","qualifiedName":"scheduled_test/scheduled_test.unittestConfiguration","comment":"<p><a>scheduled_test/scheduled_test.Configuration</a> used by the unittest library. Note that if a\nconfiguration has not been set, calling this getter will create\na default configuration.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Configuration","inner":[]}],"parameters":{},"annotations":[]},"currentSchedule":{"name":"currentSchedule","qualifiedName":"scheduled_test/scheduled_test.currentSchedule","comment":"<p>The <a>scheduled_test/scheduled_test.Schedule</a> for the current test. This is used to add new tasks and\ninspect the state of the schedule.</p>\n<p>This is <code>null</code> when there's no test currently running.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Schedule","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{},"methods":{"disableTest":{"name":"disableTest","qualifiedName":"scheduled_test/scheduled_test.disableTest","comment":"<p>Disable a test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testId":{"name":"testId","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"enableTest":{"name":"enableTest","qualifiedName":"scheduled_test/scheduled_test.enableTest","comment":"<p>Enable a test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testId":{"name":"testId","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"setSoloTest":{"name":"setSoloTest","qualifiedName":"scheduled_test/scheduled_test.setSoloTest","comment":"<p>Select a solo test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"id":{"name":"id","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"ensureInitialized":{"name":"ensureInitialized","qualifiedName":"scheduled_test/scheduled_test.ensureInitialized","comment":"<p>Lazily initializes the test library if not already initialized.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"registerException":{"name":"registerException","qualifiedName":"scheduled_test/scheduled_test.registerException","comment":"<p>Registers that an exception was caught for the current test.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"e":{"name":"e","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"trace":{"name":"trace","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"guardAsync":{"name":"guardAsync","qualifiedName":"scheduled_test/scheduled_test.guardAsync","comment":"<p><em>Deprecated</em></p>\n<p>All tests are now run an isolated <a>scheduled_test/dart-async.Zone</a>.</p>\n<p>You can safely remove calls to this method.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"tryBody":{"name":"tryBody","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"runTests":{"name":"runTests","qualifiedName":"scheduled_test/scheduled_test.runTests","comment":"<p>Runs all queued tests, one at a time.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"filterTests":{"name":"filterTests","qualifiedName":"scheduled_test/scheduled_test.filterTests","comment":"<p>Filter the tests. <a>scheduled_test/scheduled_test.filterTests.testFilter</a> can be a <a>dart-core.RegExp</a>, a <a>dart-core.String</a> or a\npredicate function. This is different to enabling/disabling tests\nin that it removes the tests completely.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testFilter":{"name":"testFilter","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"handleExternalError":{"name":"handleExternalError","qualifiedName":"scheduled_test/scheduled_test.handleExternalError","comment":"<p>Handle errors that happen outside the tests.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"e":{"name":"e","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"stack":{"name":"stack","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"solo_group":{"name":"solo_group","qualifiedName":"scheduled_test/scheduled_test.solo_group","comment":"<p>Like <a>scheduled_test/unittest.solo_test</a>, but for groups.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"skip_group":{"name":"skip_group","qualifiedName":"scheduled_test/scheduled_test.skip_group","comment":"<p>Like <a>scheduled_test/scheduled_test.skip_test</a>, but for groups.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"protectAsync2":{"name":"protectAsync2","qualifiedName":"scheduled_test/scheduled_test.protectAsync2","comment":"<p><em>Deprecated</em></p>\n<p>All tests are now run an isolated <a>scheduled_test/dart-async.Zone</a>.</p>\n<p>You can safely remove calls to this method.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"protectAsync1":{"name":"protectAsync1","qualifiedName":"scheduled_test/scheduled_test.protectAsync1","comment":"<p><em>Deprecated</em></p>\n<p>All tests are now run an isolated <a>scheduled_test/dart-async.Zone</a>.</p>\n<p>You can safely remove calls to this method.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"protectAsync0":{"name":"protectAsync0","qualifiedName":"scheduled_test/scheduled_test.protectAsync0","comment":"<p><em>Deprecated</em></p>\n<p>All tests are now run an isolated <a>scheduled_test/dart-async.Zone</a>.</p>\n<p>You can safely remove calls to this method.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsyncUntil2":{"name":"expectAsyncUntil2","qualifiedName":"scheduled_test/scheduled_test.expectAsyncUntil2","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>scheduled_test/scheduled_test.expectAsyncUntil</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsyncUntil1":{"name":"expectAsyncUntil1","qualifiedName":"scheduled_test/scheduled_test.expectAsyncUntil1","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>scheduled_test/scheduled_test.expectAsyncUntil</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsyncUntil0":{"name":"expectAsyncUntil0","qualifiedName":"scheduled_test/scheduled_test.expectAsyncUntil0","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>scheduled_test/scheduled_test.expectAsyncUntil</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsyncUntil":{"name":"expectAsyncUntil","qualifiedName":"scheduled_test/scheduled_test.expectAsyncUntil","comment":"<p>Indicate that <a>scheduled_test/scheduled_test.expectAsyncUntil.callback</a> is expected to be called until <a>scheduled_test/scheduled_test.expectAsyncUntil.isDone</a> returns\ntrue. The unittest framework check <a>scheduled_test/scheduled_test.expectAsyncUntil.isDone</a> after each callback and only\nwhen it returns true will it continue with the following test. Using\n<a>scheduled_test/scheduled_test.expectAsyncUntil</a> will also ensure that errors that occur within\n<a>scheduled_test/scheduled_test.expectAsyncUntil.callback</a> are tracked and reported. <a>scheduled_test/scheduled_test.expectAsyncUntil.callback</a> should take 0 positional\narguments (named arguments are not supported). <a>scheduled_test/scheduled_test.expectAsyncUntil.id</a> can be used to\nidentify the callback in error messages (for example if it is called\nafter the test case is complete).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"expectAsync2":{"name":"expectAsync2","qualifiedName":"scheduled_test/scheduled_test.expectAsync2","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>scheduled_test/scheduled_test.expectAsync</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsync1":{"name":"expectAsync1","qualifiedName":"scheduled_test/scheduled_test.expectAsync1","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>scheduled_test/scheduled_test.expectAsync</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsync0":{"name":"expectAsync0","qualifiedName":"scheduled_test/scheduled_test.expectAsync0","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>scheduled_test/scheduled_test.expectAsync</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsync":{"name":"expectAsync","qualifiedName":"scheduled_test/scheduled_test.expectAsync","comment":"<p>Indicate that <a>scheduled_test/scheduled_test.expectAsync.callback</a> is expected to be called a <a>scheduled_test/scheduled_test.expectAsync.count</a> number of times\n(by default 1). The unittest framework will wait for the callback to run the\nspecified <a>scheduled_test/scheduled_test.expectAsync.count</a> times before it continues with the following test.  Using\n<a>scheduled_test/scheduled_test.expectAsync</a> will also ensure that errors that occur within <a>scheduled_test/scheduled_test.expectAsync.callback</a> are\ntracked and reported. <a>scheduled_test/scheduled_test.expectAsync.callback</a> should take 0 positional arguments (named\narguments are not supported). <a>scheduled_test/scheduled_test.expectAsync.id</a> can be used to provide more\ndescriptive error messages if the callback is called more often than\nexpected. <a>scheduled_test/scheduled_test.expectAsync.max</a> can be used to specify an upper bound on the number of\ncalls; if this is exceeded the test will fail (or be marked as in error if\nit was already complete). A value of 0 for <a>scheduled_test/scheduled_test.expectAsync.max</a> (the default) will set\nthe upper bound to the same value as <a>scheduled_test/scheduled_test.expectAsync.count</a>; i.e. the callback should be\ncalled exactly <a>scheduled_test/scheduled_test.expectAsync.count</a> times. A value of -1 for <a>scheduled_test/scheduled_test.expectAsync.max</a> will mean no upper\nbound.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"skip_test":{"name":"skip_test","qualifiedName":"scheduled_test/scheduled_test.skip_test","comment":"<p>Convenience function for skipping a test.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"spec":{"name":"spec","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"scheduled_test/scheduled_test.TestFunction","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"logMessage":{"name":"logMessage","qualifiedName":"scheduled_test/scheduled_test.logMessage","comment":"<p>Can be called by tests to log status. Tests should use this\ninstead of <a>dart-core.print</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"completion":{"name":"completion","qualifiedName":"scheduled_test/scheduled_test.completion","comment":"<p>Matches a <a>scheduled_test/dart-async.Future</a> that completes succesfully with a value that matches\n<a>scheduled_test/scheduled_test.completion.matcher</a>. Note that this creates an asynchronous expectation. The call to\n<code>expect()</code> that includes this will return immediately and execution will\ncontinue. Later, when the future completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>scheduled_test/unittest-matcher.throws</a> and\n<a>scheduled_test/unittest-matcher.throwsA</a>.</p>\n<p><a>scheduled_test/scheduled_test.completion.description</a> is an optional tag that can be used to identify the completion\nmatcher in error messages.</p>\n<p>This differs from the <code>completion</code> matcher in <code>unittest</code> in that it pipes\nany errors in the Future to <a>scheduled_test/scheduled_test.currentSchedule</a>, rather than reporting them in\nthe <a>scheduled_test/unittest-matcher.expect</a>'s error message.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"scheduled_test/scheduled_test.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"description":{"name":"description","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"wrapFuture":{"name":"wrapFuture","qualifiedName":"scheduled_test/scheduled_test.wrapFuture","comment":"<p>Like wrapAsync, this ensures that the current task queue waits for\nout-of-band asynchronous code, and that errors raised in that code are\nhandled correctly. However, <a>scheduled_test/scheduled_test.wrapFuture</a> wraps a <a>scheduled_test/dart-async.Future</a> chain rather than\na single callback.</p>\n<p>The returned <a>scheduled_test/dart-async.Future</a> completes to the same value or error as <a>scheduled_test/scheduled_test.wrapFuture.future</a>.</p>\n<p><a>scheduled_test/scheduled_test.wrapFuture.description</a> provides an optional description of the future, which is\nused when generating error messages.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"future":{"name":"future","optional":false,"named":false,"default":false,"type":[{"outer":"dart-async.Future","inner":[]}],"value":"null","annotations":[]},"description":{"name":"description","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"setUp":{"name":"setUp","qualifiedName":"scheduled_test/scheduled_test.setUp","comment":"<p>Register a <a>scheduled_test/scheduled_test.setUp</a> function for a test <a>scheduled_test/scheduled_test.group</a>. This has the same semantics\nas <a>scheduled_test/unittest.setUp</a>. Tasks may be scheduled using <a>scheduled_test/scheduled_test.schedule</a> within\n<a>scheduled_test/scheduled_test.setUp.setUpFn</a>, and <a>scheduled_test/scheduled_test.currentSchedule</a> may be accessed as well.</p>\n<p>Note that there is no associated tearDown function. Instead, tasks should\nbe scheduled for currentSchedule.onComplete or\ncurrentSchedule.onException. These tasks will be run after each test's\nschedule is completed.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"setUpFn":{"name":"setUpFn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"schedule":{"name":"schedule","qualifiedName":"scheduled_test/scheduled_test.schedule","comment":"<p>Schedules a task, <a>scheduled_test/scheduled_test.schedule.fn</a>, to run asynchronously as part of the main task queue\nof <a>scheduled_test/scheduled_test.currentSchedule</a>. Tasks will be run in the order they're scheduled. If\n<a>scheduled_test/scheduled_test.schedule.fn</a> returns a <a>scheduled_test/dart-async.Future</a>, tasks after it won't be run until that <a>scheduled_test/dart-async.Future</a>\ncompletes.</p>\n<p>The return value will be completed once the scheduled task has finished\nrunning. Its return value is the same as the return value of <a>scheduled_test/scheduled_test.schedule.fn</a>, or the\nvalue it completes to if it's a <a>scheduled_test/dart-async.Future</a>.</p>\n<p>If <a>scheduled_test/scheduled_test.schedule.description</a> is passed, it's used to describe the task for debugging\npurposes when an error occurs.</p>\n<p>If this is called when a task queue is currently running, it will run <a>scheduled_test/scheduled_test.schedule.fn</a>\non the next event loop iteration rather than adding it to a queue. The\ncurrent task will not complete until <a>scheduled_test/scheduled_test.schedule.fn</a> (and any <a>scheduled_test/dart-async.Future</a> it returns) has\nfinished running. Any errors in <a>scheduled_test/scheduled_test.schedule.fn</a> will automatically be handled.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"description":{"name":"description","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"group":{"name":"group","qualifiedName":"scheduled_test/scheduled_test.group","comment":"<p>Creates a new named group of tests. This has the same semantics as\n<a>scheduled_test/unittest.group</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"solo_test":{"name":"solo_test","qualifiedName":"scheduled_test/scheduled_test.solo_test","comment":"<p>Creates a new test case with the given description and body that will be the\nonly test run in this file. This has the same semantics as\n<a>scheduled_test/unittest.solo_test</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"test":{"name":"test","qualifiedName":"scheduled_test/scheduled_test.test","comment":"<p>Creates a new test case with the given description and body. This has the\nsame semantics as <a>scheduled_test/unittest.test</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"TestCase","qualifiedName":"scheduled_test/scheduled_test.TestCase","preview":"<p>Represents the state for an individual unit test.</p>"},{"name":"SimpleConfiguration","qualifiedName":"scheduled_test/scheduled_test.SimpleConfiguration","preview":"<p>Hooks to configure the unittest library for different platforms. This class\nimplements the API in a platform-independent way. Tests that want to take\nadvantage of the platform can create a subclass and override methods from\nthis class.</p>"},{"name":"Configuration","qualifiedName":"scheduled_test/scheduled_test.Configuration","preview":"<p>Describes the interface used by the unit test system for communicating the\nresults of a test run.</p>"},{"name":"PendingCallback","qualifiedName":"scheduled_test/scheduled_test.PendingCallback","preview":"<p>An identifier for an out-of-band callback running during a schedule.</p>"},{"name":"TaskQueue","qualifiedName":"scheduled_test/scheduled_test.TaskQueue","preview":"<p>A queue of asynchronous tasks to execute in order.</p>"},{"name":"ScheduleState","qualifiedName":"scheduled_test/scheduled_test.ScheduleState","preview":"<p>An enum of states for a <a>scheduled_test/scheduled_test.Schedule</a>.</p>"},{"name":"Schedule","qualifiedName":"scheduled_test/scheduled_test.Schedule","preview":"<p>The schedule of tasks to run for a single test. This has three separate task\nqueues: <a>scheduled_test/scheduled_test.Schedule.tasks</a>, <a>scheduled_test/scheduled_test.Schedule.onComplete</a>, and <a>scheduled_test/scheduled_test.Schedule.onException</a>. It also provides\nvisibility into the current state of the schedule.</p>"},{"name":"ScheduleError","qualifiedName":"scheduled_test/scheduled_test.ScheduleError","preview":"<p>A wrapper for errors that occur during a scheduled test.</p>"},{"name":"TaskState","qualifiedName":"scheduled_test/scheduled_test.TaskState","preview":"<p>An enum of states for a <a>scheduled_test/scheduled_test.Task</a>.</p>"},{"name":"Task","qualifiedName":"scheduled_test/scheduled_test.Task","preview":"<p>A single task to be run as part of a <a>scheduled_test/scheduled_test.TaskQueue</a>.</p>"}],"typedef":{"TestFunction":{"name":"TestFunction","qualifiedName":"scheduled_test/scheduled_test.TestFunction","comment":"<p>Signature for a test function.</p>","return":"dynamic","parameters":{},"annotations":[],"generics":{},"preview":"<p>Signature for a test function.</p>"},"TaskBody":{"name":"TaskBody","qualifiedName":"scheduled_test/scheduled_test.TaskBody","comment":"","return":"dart-async.Future","parameters":{},"annotations":[],"generics":{}}},"error":[]},"packageName":"scheduled_test","packageIntro":""}