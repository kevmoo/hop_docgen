{"name":"string_scanner","qualifiedName":"string_scanner/string_scanner","comment":"<p>A library for parsing strings using a sequence of patterns.</p>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{}},"classes":{"class":[{"name":"StringScanner","qualifiedName":"string_scanner/string_scanner.StringScanner","preview":"<p>A class that scans through a string using <a>string_scanner/dart-core.Pattern</a>s.</p>"}],"typedef":{},"error":[]},"packageName":"string_scanner","packageIntro":"<p>This package exposes a <code>StringScanner</code> type that makes it easy to parse a string\nusing a series of <code>Pattern</code>s. For example:</p>\n<pre class=\"dart\"><code>import 'dart:math';\n\nimport 'package:string_scanner/string_scanner.dart';\n\nnum parseNumber(String source) {\n  // Scan a number (\"1\", \"1.5\", \"-3\").\n  var scanner = new StringScanner(source);\n\n  // [Scanner.scan] tries to consume a [Pattern] and returns whether or not it\n  // succeeded. It will move the scan pointer past the end of the pattern.\n  var negative = scanner.scan(\"-\");\n\n  // [Scanner.expect] consumes a [Pattern] and throws a [FormatError] if it\n  // fails. Like [Scanner.scan], it will move the scan pointer forward.\n  scanner.expect(new RegExp(r\"\\d+\"));\n\n  // [Scanner.lastMatch] holds the [MatchData] for the most recent call to\n  // [Scanner.scan], [Scanner.expect], or [Scanner.matches].\n  var number = int.parse(scanner.lastMatch[0]);\n\n  if (scanner.scan(\".\")) {\n    scanner.expect(new RegExp(r\"\\d+\"));\n    var decimal = scanner.lastMatch[0];\n    number += int.parse(decimal) / math.pow(10, decimal.length);\n  }\n\n  // [Scanner.expectDone] will throw a [FormatError] if there's any input that\n  // hasn't yet been consumed.\n  scanner.expectDone();\n\n  return (negative ? -1 : 1) * number;\n}\n</code></pre>"}