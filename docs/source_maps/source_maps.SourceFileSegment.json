{"name":"SourceFileSegment","qualifiedName":"source_maps/source_maps.SourceFileSegment","comment":"<p>A convenience type to treat a code segment as if it were a separate\n<a>source_maps/source_maps.SourceFile</a>. A <a>source_maps/source_maps.SourceFileSegment</a> shifts all locations by an offset, which\nallows you to set source-map locations based on the locations relative to\nthe start of the segment, but that get translated to absolute locations in\nthe original source file.</p>","isAbstract":false,"superclass":"source_maps/source_maps.SourceFile","implements":[],"subclass":[],"variables":{},"inheritedVariables":{"url":{"name":"url","qualifiedName":"source_maps/source_maps.SourceFile.url","comment":"<p>Url where the source file is located.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{},"constructors":{"":{"name":"","qualifiedName":"source_maps/source_maps.SourceFileSegment.SourceFileSegment-","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"textSegment":{"name":"textSegment","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"startOffset":{"name":"startOffset","optional":false,"named":false,"default":false,"type":[{"outer":"source_maps/source_maps.Location","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"operators":{},"methods":{"span":{"name":"span","qualifiedName":"source_maps/source_maps.SourceFileSegment.span","comment":"<p>Craete a span, where <a>source_maps/source_maps.SourceFileSegment.span.start</a> is relative to this segment's base offset.\nThe returned span stores the real offset on the file, so that error\nmessages are reported at the real location.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"source_maps/source_maps.Span","inner":[]}],"parameters":{"start":{"name":"start","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"end":{"name":"end","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"isIdentifier":{"name":"isIdentifier","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"location":{"name":"location","qualifiedName":"source_maps/source_maps.SourceFileSegment.location","comment":"<p>Create a location, where <a>source_maps/source_maps.SourceFileSegment.location.offset</a> relative to this segment's base offset.\nThe returned span stores the real offset on the file, so that error\nmessages are reported at the real location.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"source_maps/source_maps.Location","inner":[]}],"parameters":{"offset":{"name":"offset","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getLine":{"name":"getLine","qualifiedName":"source_maps/source_maps.SourceFileSegment.getLine","comment":"<p>Return the line on the underlying file associated with the <a>source_maps/source_maps.SourceFileSegment.getLine.offset</a> of the\nunderlying file. This method operates on the real offsets from the\noriginal file, so that error messages can be reported accurately. When the\nrequested offset is past the length of the segment, this returns the line\nnumber after the end of the segment (total lines + 1).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"offset":{"name":"offset","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getColumn":{"name":"getColumn","qualifiedName":"source_maps/source_maps.SourceFileSegment.getColumn","comment":"<p>Return the column on the underlying file associated with <a>source_maps/source_maps.SourceFileSegment.getColumn.line</a> and\n<a>source_maps/source_maps.SourceFileSegment.getColumn.offset</a>, where <a>source_maps/source_maps.SourceFileSegment.getColumn.line</a> is absolute from the beginning of the underlying\nfile. This method operates on the real offsets from the original file, so\nthat error messages can be reported accurately.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"line":{"name":"line","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"offset":{"name":"offset","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getOffset":{"name":"getOffset","qualifiedName":"source_maps/source_maps.SourceFileSegment.getOffset","comment":"<p>Return the offset associated with a line and column. This method operates\non the real offsets from the original file, so that error messages can be\nreported accurately.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"line":{"name":"line","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"column":{"name":"column","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getText":{"name":"getText","qualifiedName":"source_maps/source_maps.SourceFileSegment.getText","comment":"<p>Retrieve the text associated with the specified range. This method\noperates on the real offsets from the original file, so that error\nmessages can be reported accurately.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"start":{"name":"start","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"end":{"name":"end","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"source_maps/source_maps.SourceFileSegment.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>source_maps/source_maps.SourceFileSegment.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"source_maps/source_maps.SourceFileSegment.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"source_maps/source_maps.SourceFileSegment.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>source_maps/source_maps.SourceFileSegment.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>source_maps/source_maps.SourceFileSegment.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"methods":{"toString":{"name":"toString","qualifiedName":"source_maps/source_maps.SourceFileSegment.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"source_maps/source_maps.SourceFileSegment.noSuchMethod","comment":"<p><a>source_maps/source_maps.SourceFileSegment.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>source_maps/source_maps.SourceFileSegment.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>source_maps/source_maps.SourceFileSegment.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>source_maps/source_maps.SourceFileSegment.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"span":{"name":"span","qualifiedName":"source_maps/source_maps.SourceFileSegment.span","comment":"<p>Returns a span in this <a>source_maps/source_maps.SourceFile</a> with the given offsets.</p>","commentFrom":"","inheritedFrom":"source_maps.SourceFile.span","static":false,"abstract":false,"constant":false,"return":[{"outer":"source_maps/source_maps.Span","inner":[]}],"parameters":{"start":{"name":"start","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"end":{"name":"end","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"isIdentifier":{"name":"isIdentifier","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"location":{"name":"location","qualifiedName":"source_maps/source_maps.SourceFileSegment.location","comment":"<p>Returns a location in this <a>source_maps/source_maps.SourceFile</a> with the given offset.</p>","commentFrom":"","inheritedFrom":"source_maps.SourceFile.location","static":false,"abstract":false,"constant":false,"return":[{"outer":"source_maps/source_maps.Location","inner":[]}],"parameters":{"offset":{"name":"offset","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getLine":{"name":"getLine","qualifiedName":"source_maps/source_maps.SourceFileSegment.getLine","comment":"<p>Gets the 0-based line corresponding to an offset.</p>","commentFrom":"","inheritedFrom":"source_maps.SourceFile.getLine","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"offset":{"name":"offset","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getColumn":{"name":"getColumn","qualifiedName":"source_maps/source_maps.SourceFileSegment.getColumn","comment":"<p>Gets the 0-based column corresponding to an offset.</p>","commentFrom":"","inheritedFrom":"source_maps.SourceFile.getColumn","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"line":{"name":"line","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"offset":{"name":"offset","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getOffset":{"name":"getOffset","qualifiedName":"source_maps/source_maps.SourceFileSegment.getOffset","comment":"<p>Get the offset for a given line and column</p>","commentFrom":"","inheritedFrom":"source_maps.SourceFile.getOffset","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"line":{"name":"line","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"column":{"name":"column","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getText":{"name":"getText","qualifiedName":"source_maps/source_maps.SourceFileSegment.getText","comment":"<p>Gets the text at the given offsets.</p>","commentFrom":"","inheritedFrom":"source_maps.SourceFile.getText","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"start":{"name":"start","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"end":{"name":"end","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getLocationMessage":{"name":"getLocationMessage","qualifiedName":"source_maps/source_maps.SourceFileSegment.getLocationMessage","comment":"<p>Create a pretty string representation from a span.</p>","commentFrom":"","inheritedFrom":"source_maps.SourceFile.getLocationMessage","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"start":{"name":"start","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"end":{"name":"end","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"useColors":{"name":"useColors","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]},"color":{"name":"color","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"annotations":[],"generics":{}}